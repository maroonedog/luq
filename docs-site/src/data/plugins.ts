// This file is auto-generated by generate-plugin-docs-from-jsdoc.js
// Do not edit manually!

export interface PluginInfo {
  functionName: string;
  displayName: string;
  category: string;
  description: string;
  usage: string;
  supportedTypes?: string[];
  parameters?: Array<{
    name: string;
    type: string;
    description: string;
    optional?: boolean;
  }>;
  examples: Array<{
    title: string;
    code: string;
  }>;
  returns?: string;
}

export const pluginCategories = {
  "array": "array",
  "standard": "standard",
  "advanced": "advanced",
  "context": "context",
  "builder-extension": "builder-extension",
  "object": "object",
  "conditional": "conditional",
  "multiFieldReference": "multiFieldReference",
  "string": "string",
  "transform": "transform",
  "composable-directly": "composable-directly",
  "composable-conditional": "composable-conditional"
} as const;

export const plugins: PluginInfo[] = [
  {
    "functionName": "arrayContains",
    "displayName": "contains",
    "category": "array",
    "description": "Validates that an array contains at least one item matching the specified schema or value",
    "usage": ".v(\"items\", b => b.array.contains({ validator: (value) => typeof value === 'number' && value > 10, message: \"Array must contain at least one number greater than 10\" })",
    "supportedTypes": [
      "array"
    ],
    "parameters": [
      {
        "name": "schema",
        "type": "any | { validator: (value: any) => boolean, message?: string }",
        "optional": false,
        "description": "Value or validation schema"
      }
    ],
    "examples": [
      {
        "title": "Contains specific value",
        "code": "// Contains specific value\r\nconst validator = Builder()\r\n  .use(arrayContainsPlugin)\r\n  .for<{ tags: string[] }>()\r\n  .v(\"tags\", (b) => b.array.contains(\"important\"))\r\n  .build();\r\n\n// Contains matching schema\r\nbuilder.v(\"items\", b => b.array.contains({\r\n  validator: (value) => typeof value === 'number' && value > 10,\r\n  message: \"Array must contain at least one number greater than 10\"\r\n}))"
      }
    ],
    "returns": "Validation function that checks if array contains matching item"
  },
  {
    "functionName": "arrayIncludes",
    "displayName": "includes",
    "category": "standard",
    "description": "Validates that an array contains a specific required element",
    "usage": "builder.v(\"field\", b => b.string.includes(..., \"value\"))",
    "supportedTypes": [
      "array"
    ],
    "parameters": [
      {
        "name": "expected",
        "type": "any",
        "optional": false,
        "description": "The element that must be present in the array"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - check if array contains specific item",
        "code": "// Basic usage - check if array contains specific item\r\nconst validator = Builder()\r\n  .use(arrayIncludesPlugin)\r\n  .for<UserData>()\r\n  .v(\"roles\", (b) => b.array.includes(\"admin\"))\r\n  .v(\"permissions\", (b) => b.array.includes(\"read\"))\r\n  .build();\r\n\n// Multiple required items\r\nbuilder.v(\"features\", b => b.array\r\n  .includes(\"core\")\r\n  .includes(\"api\")\r\n)"
      }
    ],
    "returns": "Validation function that returns true if array contains the expected element"
  },
  {
    "functionName": "arrayMaxLength",
    "displayName": "maxLength",
    "category": "standard",
    "description": "Validates that an array does not exceed the specified maximum number of elements",
    "usage": ".v(\"files\", b => b.array.minLength(1).maxLength(3)",
    "supportedTypes": [
      "array"
    ],
    "parameters": [
      {
        "name": "maxLength",
        "type": "number",
        "optional": false,
        "description": "Maximum number of elements allowed"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - set maximum array length",
        "code": "// Basic usage - set maximum array length\r\nconst validator = Builder()\r\n  .use(arrayMaxLengthPlugin)\r\n  .for<FormData>()\r\n  .v(\"tags\", (b) => b.array.maxLength(10))\r\n  .v(\"attachments\", (b) => b.array.maxLength(5))\r\n  .build();\r\n\n// Limit file uploads with min and max\r\nbuilder.v(\"files\", b => b.array.minLength(1).maxLength(3))"
      }
    ],
    "returns": "Validation function that returns true if array length does not exceed maximum"
  },
  {
    "functionName": "arrayMinLength",
    "displayName": "minLength",
    "category": "standard",
    "description": "Validates that an array has at least the specified minimum number of elements",
    "usage": ".v(\"selectedOptions\", b => b.array.required().minLength(1)",
    "supportedTypes": [
      "array"
    ],
    "parameters": [
      {
        "name": "minLength",
        "type": "number",
        "optional": false,
        "description": "Minimum number of elements required"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - set minimum array length",
        "code": "// Basic usage - set minimum array length\r\nconst validator = Builder()\r\n  .use(arrayMinLengthPlugin)\r\n  .for<FormData>()\r\n  .v(\"tags\", (b) => b.array.minLength(1))\r\n  .v(\"items\", (b) => b.array.minLength(3))\r\n  .build();\r\n\n// Ensure non-empty array\r\nbuilder.v(\"selectedOptions\", b => b.array.required().minLength(1))"
      }
    ],
    "returns": "Validation function that returns true if array length is at least the minimum"
  },
  {
    "functionName": "arrayUnique",
    "displayName": "unique",
    "category": "standard",
    "description": "Validates that all elements in an array are unique (no duplicates)",
    "usage": ".v(\"tags\", b => b.array.unique().minLength(1)",
    "supportedTypes": [
      "array"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures all array elements are unique",
        "code": "// Basic usage - ensures all array elements are unique\r\nconst validator = Builder()\r\n  .use(arrayUniquePlugin)\r\n  .for<FormData>()\r\n  .v(\"emails\", (b) => b.array.unique())\r\n  .v(\"userIds\", (b) => b.array.required().unique())\r\n  .build();\r\n\n// For tags or categories\r\nbuilder.v(\"tags\", b => b.array.unique().minLength(1).maxLength(10))\r\n\n// Combining with other array validations\r\nbuilder.v(\"productCodes\", b => b.array.unique().includes(\"PRIMARY\"))"
      }
    ],
    "returns": "Validation function that returns true if all array elements are unique"
  },
  {
    "functionName": "booleanFalsy",
    "displayName": "falsy",
    "category": "standard",
    "description": "Validates that a boolean value is exactly false",
    "usage": ".v(\"shareData\", b => b.boolean.falsy())",
    "supportedTypes": [
      "boolean"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures value is exactly false",
        "code": "// Basic usage - ensures value is exactly false\r\nconst validator = Builder()\r\n  .use(booleanFalsyPlugin)\r\n  .for<Settings>()\r\n  .v(\"isActive\", (b) => b.boolean.falsy())\r\n  .v(\"debugMode\", (b) => b.boolean.required().falsy())\r\n  .build();\r\n\n// Privacy settings\r\nbuilder.v(\"shareData\", b => b.boolean.falsy())\r\n\n// Security flags\r\nbuilder.v(\"allowExternalAccess\", b => b.boolean.required().falsy())"
      }
    ],
    "returns": "Validation function that returns true if value is exactly false"
  },
  {
    "functionName": "booleanTruthy",
    "displayName": "truthy",
    "category": "standard",
    "description": "Validates that a boolean value is exactly true",
    "usage": ".v(\"agreeToTerms\", b => b.boolean.required().truthy()",
    "supportedTypes": [
      "boolean"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensure value is exactly true",
        "code": "// Basic usage - ensure value is exactly true\r\nconst validator = Builder()\r\n  .use(booleanTruthyPlugin)\r\n  .for<FormData>()\r\n  .v(\"isActive\", (b) => b.boolean.truthy())\r\n  .v(\"termsAccepted\", (b) => b.boolean.required().truthy())\r\n  .build();\r\n\n// For consent checkboxes\r\nbuilder.v(\"agreeToTerms\", b => b.boolean.required().truthy())"
      }
    ],
    "returns": "Validation function that returns true only if value is exactly true"
  },
  {
    "functionName": "compareField",
    "displayName": "compareField",
    "category": "standard",
    "description": "Validates a field's value by comparing it with another field's value using a custom comparison function",
    "usage": "builder.v(\"endDate\", (b) => b.string.datetime().compareField(\"startDate\", {",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "date",
      "object",
      "array",
      "null",
      "undefined"
    ],
    "parameters": [
      {
        "name": "fieldPath",
        "type": "string",
        "optional": false,
        "description": "Path to the field to compare against (supports dot notation)"
      },
      {
        "name": "options",
        "type": "{ compareFn?: (value, targetValue) => boolean, messageFactory?: (context) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Default usage - strict equality",
        "code": "// Default usage - strict equality\r\nconst validator = Builder()\r\n  .use(compareFieldPlugin)\r\n  .for<SignupForm>()\r\n  .v(\"password\", (b) => b.string.required().min(8))\r\n  .v(\"confirmPassword\", (b) => b.string.required().compareField(\"password\"))\r\n  .build();\r\n\n// Custom comparison - date before\r\nbuilder.v(\"endDate\", (b) => b.string.datetime().compareField(\"startDate\", {\r\n  compareFn: (endDate, startDate) => new Date(endDate) > new Date(startDate),\r\n  messageFactory: () => \"End date must be after start date\"\r\n}))\r\n\n// Number comparison\r\nbuilder.v(\"maxValue\", (b) => b.number.compareField(\"minValue\", {\r\n  compareFn: (max, min) => max >= min,\r\n  messageFactory: () => \"Max value must be greater than or equal to min value\"\r\n}))"
      }
    ],
    "returns": "Validation function that returns true if comparison passes"
  },
  {
    "functionName": "conditionalSchema",
    "displayName": "conditionalSchema",
    "category": "advanced",
    "description": "Validates based on if/then/else conditions",
    "usage": ".v(\"field\", b => b.string.conditionalSchema(...))",
    "supportedTypes": [
      "object"
    ],
    "parameters": [],
    "examples": [],
    "returns": ""
  },
  {
    "functionName": "custom",
    "displayName": "custom",
    "category": "standard",
    "description": "Allows custom validation logic",
    "usage": "builder.v(\"field\", b => b.string.custom(true, \"value\"))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "date",
      "array",
      "object",
      "tuple",
      "union"
    ],
    "parameters": [
      {
        "name": "validator",
        "type": "(value: any, rootData?: any) => boolean",
        "optional": false,
        "description": "Custom validation function"
      },
      {
        "name": "options",
        "type": "{ code?: string; messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Error customization"
      }
    ],
    "examples": [
      {
        "title": "Basic custom validation",
        "code": "// Basic custom validation\r\nbuilder.v(\"username\", b => b.string\r\n  .custom((value) => {\r\n    return !reservedUsernames.includes(value);\r\n  }, {\r\n    code: 'RESERVED_USERNAME',\r\n    messageFactory: ({ path }) => `${path} username is reserved`\r\n  })\r\n)\r\n\n// With access to all values\r\nbuilder.v(\"confirmPassword\", b => b.string\r\n  .custom((value, rootData) => {\r\n    return value === rootData.password;\r\n  }, {\r\n    code: 'PASSWORD_MISMATCH',\r\n    messageFactory: ({ path }) => `${path} passwords do not match`\r\n  })\r\n)"
      }
    ],
    "returns": "Validation function with custom logic"
  },
  {
    "functionName": "fromContext",
    "displayName": "fromContext",
    "category": "context",
    "description": "Validation using context data (async context, allValues, etc.)",
    "usage": ".v(\"confirmPassword\", b => b.string.fromContext({ validate: (confirmPassword, context, allValues) => ({ valid: allValues.password === confirmPassword, message: \"Password confirmation does not match\" })",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "object",
      "array",
      "date",
      "union",
      "tuple"
    ],
    "parameters": [
      {
        "name": "validate",
        "type": "(value, context, allValues) => { valid: boolean; message?: string }",
        "optional": false,
        "description": "Validation function"
      },
      {
        "name": "errorMessage",
        "type": "string",
        "optional": true,
        "description": "Custom error message"
      },
      {
        "name": "required",
        "type": "boolean",
        "optional": true,
        "description": "Whether context data is required (default: false)"
      },
      {
        "name": "fallbackToValid",
        "type": "boolean",
        "optional": true,
        "description": "Whether to consider valid when no context (default: true)"
      }
    ],
    "examples": [
      {
        "title": "Basic usage",
        "code": "// Basic usage\r\nconst validator = Builder()\r\n  .use(fromContextPlugin)\r\n  .for<{ email: string }>()\r\n  .v(\"email\", (b) => b.string.required().fromContext({\r\n    validate: (email, context) => ({\r\n      valid: !context.hasEmail,\r\n      message: \"Email already exists\"\r\n    }),\r\n    required: true\r\n  }))\r\n  .build();\r\n\n// Combination with async context\r\nconst asyncContext = createAsyncContext<{ hasEmail: boolean }>()\r\n  .set(\"hasEmail\", checkEmailExists(email))\r\n  .build();\r\n\nconst result = await validator\r\n  .withAsyncContext<{ hasEmail: boolean }>(asyncContext)\r\n  .validate({ email: \"test@example.com\" });\r\n\n// Cross-field validation (using allValues)\r\nbuilder.v(\"confirmPassword\", b => b.string.fromContext({\r\n  validate: (confirmPassword, context, allValues) => ({\r\n    valid: allValues.password === confirmPassword,\r\n    message: \"Password confirmation does not match\"\r\n  }),\r\n  required: false // Async context not needed when using allValues\r\n}))"
      }
    ],
    "returns": "Validation result using context data"
  },
  {
    "functionName": "jsonSchemaFullFeature",
    "displayName": "jsonSchemaFullFeature",
    "category": "builder-extension",
    "description": "Complete JSON Schema support with all necessary plugins pre-loaded",
    "usage": "builder.v(\"field\", b => b.string.jsonSchemaFullFeature())",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union",
      "tuple"
    ],
    "parameters": [],
    "examples": [
      {
        "title": "Single plugin import for full JSON Schema support",
        "code": "// Single plugin import for full JSON Schema support\r\nconst validator = Builder()\r\n  .use(jsonSchemaFullFeaturePlugin)\r\n  .fromJsonSchema({\r\n    type: 'object',\r\n    properties: {\r\n      email: { type: 'string', format: 'email' },\r\n      age: { type: 'number', minimum: 18 },\r\n      roles: {\r\n        type: 'array',\r\n        items: { type: 'string' },\r\n        uniqueItems: true\r\n      }\r\n    },\r\n    required: ['email'],\r\n    additionalProperties: false\r\n  })\r\n  .build();"
      }
    ],
    "returns": ""
  },
  {
    "functionName": "literal",
    "displayName": "literal",
    "category": "standard",
    "description": "Validates that a value exactly matches a specific literal value",
    "usage": ".v(\"maxRetries\", b => b.number.literal(3))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "null"
    ],
    "parameters": [
      {
        "name": "expected",
        "type": "string | number | boolean | null",
        "optional": false,
        "description": "The exact value to match"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "String literal - exact value match",
        "code": "// String literal - exact value match\r\nconst validator = Builder()\r\n  .use(literalPlugin)\r\n  .for<Config>()\r\n  .v(\"type\", (b) => b.string.literal(\"user\"))\r\n  .v(\"version\", (b) => b.string.literal(\"v1\"))\r\n  .build();\r\n\n// Number and boolean literals\r\nbuilder.v(\"maxRetries\", b => b.number.literal(3))\r\nbuilder.v(\"enabled\", b => b.boolean.literal(true))"
      }
    ],
    "returns": "Validation function that returns true only if value exactly matches expected"
  },
  {
    "functionName": "nullable",
    "displayName": "nullable",
    "category": "standard",
    "description": "Allows a field to accept null as a valid value",
    "usage": ".v(\"score\", b => b.number.nullable().min(0)",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [],
    "examples": [
      {
        "title": "Basic usage - field can be null or valid string",
        "code": "// Basic usage - field can be null or valid string\r\nconst validator = Builder()\r\n  .use(nullablePlugin)\r\n  .for<UserProfile>()\r\n  .v(\"middleName\", (b) => b.string.nullable().min(3))\r\n  .v(\"avatar\", (b) => b.string.nullable().url())\r\n  .build();\r\n\n// With other validations - null bypasses all validators\r\nbuilder.v(\"score\", b => b.number.nullable().min(0).max(100))"
      }
    ],
    "returns": "Validation function that returns true for null values and continues validation for non-null values"
  },
  {
    "functionName": "numberFinite",
    "displayName": "finite",
    "category": "standard",
    "description": "Validates that a number is finite (not Infinity, -Infinity, or NaN)",
    "usage": ".v(\"average\", b => b.number.finite().min(0)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures number is finite",
        "code": "// Basic usage - ensures number is finite\r\nconst validator = Builder()\r\n  .use(numberFinitePlugin)\r\n  .for<CalculationResult>()\r\n  .v(\"score\", (b) => b.number.finite())\r\n  .v(\"ratio\", (b) => b.number.required().finite())\r\n  .build();\r\n\n// For division results that might be infinite\r\nbuilder.v(\"average\", b => b.number.finite().min(0))\r\n\n// For mathematical calculations\r\nbuilder.v(\"result\", b => b.number.required().finite().range(-1000, 1000))"
      }
    ],
    "returns": "Validation function that returns true if number is finite"
  },
  {
    "functionName": "numberInteger",
    "displayName": "integer",
    "category": "standard",
    "description": "Validates that a number is an integer (whole number without decimals)",
    "usage": ".v(\"score\", b => b.number.integer().min(0)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures number is an integer",
        "code": "// Basic usage - ensures number is an integer\r\nconst validator = Builder()\r\n  .use(numberIntegerPlugin)\r\n  .for<OrderData>()\r\n  .v(\"quantity\", (b) => b.number.integer())\r\n  .v(\"count\", (b) => b.number.required().integer())\r\n  .build();\r\n\n// Combined with range validation\r\nbuilder.v(\"score\", b => b.number.integer().min(0).max(100))\r\n\n// For ID validation\r\nbuilder.v(\"userId\", b => b.number.required().integer().positive())"
      }
    ],
    "returns": "Validation function that returns true if number is an integer"
  },
  {
    "functionName": "numberMax",
    "displayName": "max",
    "category": "standard",
    "description": "Validates that a number is less than or equal to the specified maximum value",
    "usage": ".v(\"successRate\", b => b.number.min(0).max(100)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "max",
        "type": "number",
        "optional": false,
        "description": "Maximum allowed value (inclusive)"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - set maximum allowed value",
        "code": "// Basic usage - set maximum allowed value\r\nconst validator = Builder()\r\n  .use(numberMaxPlugin)\r\n  .for<Settings>()\r\n  .v(\"percentage\", (b) => b.number.max(100))\r\n  .v(\"discount\", (b) => b.number.max(50))\r\n  .v(\"temperature\", (b) => b.number.max(40))\r\n  .build();\r\n\n// For percentages with range\r\nbuilder.v(\"successRate\", b => b.number.min(0).max(100))"
      }
    ],
    "returns": "Validation function that returns true if number is less than or equal to maximum"
  },
  {
    "functionName": "numberMin",
    "displayName": "min",
    "category": "standard",
    "description": "Validates that a number is greater than or equal to the specified minimum value",
    "usage": ".v(\"percentage\", b => b.number.min(0).max(100)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "min",
        "type": "number",
        "optional": false,
        "description": "Minimum allowed value (inclusive)"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - set minimum allowed value",
        "code": "// Basic usage - set minimum allowed value\r\nconst validator = Builder()\r\n  .use(numberMinPlugin)\r\n  .for<OrderForm>()\r\n  .v(\"age\", (b) => b.number.min(18))\r\n  .v(\"quantity\", (b) => b.number.min(1))\r\n  .v(\"price\", (b) => b.number.min(0.01))\r\n  .build();\r\n\n// Combined with max for range validation\r\nbuilder.v(\"percentage\", b => b.number.min(0).max(100))"
      }
    ],
    "returns": "Validation function that returns true if number is greater than or equal to minimum"
  },
  {
    "functionName": "numberMultipleOf",
    "displayName": "multipleOf",
    "category": "standard",
    "description": "Validates that a number is a multiple of a specified divisor",
    "usage": ".v(\"duration\", b => b.number.multipleOf(15).min(0)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "divisor",
        "type": "number",
        "optional": false,
        "description": "The number that the value must be divisible by"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures number is a multiple of divisor",
        "code": "// Basic usage - ensures number is a multiple of divisor\r\nconst validator = Builder()\r\n  .use(numberMultipleOfPlugin)\r\n  .for<PricingData>()\r\n  .v(\"quantity\", (b) => b.number.multipleOf(5))\r\n  .v(\"price\", (b) => b.number.required().multipleOf(0.25))\r\n  .build();\r\n\n// For time intervals (minutes)\r\nbuilder.v(\"duration\", b => b.number.multipleOf(15).min(0).max(240))\r\n\n// For currency with cents\r\nbuilder.v(\"amount\", b => b.number.multipleOf(0.01).positive())"
      }
    ],
    "returns": "Validation function that returns true if number is a multiple of divisor"
  },
  {
    "functionName": "numberNegative",
    "displayName": "negative",
    "category": "standard",
    "description": "Validates that a number is strictly negative (less than zero)",
    "usage": ".v(\"celsius\", b => b.number.negative().max(-1)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures number is negative (< 0)",
        "code": "// Basic usage - ensures number is negative (< 0)\r\nconst validator = Builder()\r\n  .use(numberNegativePlugin)\r\n  .for<TemperatureData>()\r\n  .v(\"temperature\", (b) => b.number.negative())\r\n  .v(\"debt\", (b) => b.number.required().negative())\r\n  .build();\r\n\n// For temperature below freezing\r\nbuilder.v(\"celsius\", b => b.number.negative().max(-1))\r\n\n// For negative offsets or adjustments\r\nbuilder.v(\"adjustment\", b => b.number.negative().integer())"
      }
    ],
    "returns": "Validation function that returns true if number is less than zero"
  },
  {
    "functionName": "numberPositive",
    "displayName": "positive",
    "category": "standard",
    "description": "Validates that a number is strictly positive (greater than zero)",
    "usage": ".v(\"payment\", b => b.number.positive().multipleOf(0.01)",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures number is positive (> 0)",
        "code": "// Basic usage - ensures number is positive (> 0)\r\nconst validator = Builder()\r\n  .use(numberPositivePlugin)\r\n  .for<PricingData>()\r\n  .v(\"price\", (b) => b.number.positive())\r\n  .v(\"quantity\", (b) => b.number.required().positive())\r\n  .build();\r\n\n// For monetary values\r\nbuilder.v(\"payment\", b => b.number.positive().multipleOf(0.01))\r\n\n// For counts and quantities\r\nbuilder.v(\"itemCount\", b => b.number.positive().integer())"
      }
    ],
    "returns": "Validation function that returns true if number is greater than zero"
  },
  {
    "functionName": "numberRange",
    "displayName": "range",
    "category": "standard",
    "description": "Validates that a number is within a specified range (inclusive)",
    "usage": ".v(\"rating\", b => b.number.range(1, 5).integer()",
    "supportedTypes": [
      "number"
    ],
    "parameters": [
      {
        "name": "min",
        "type": "number",
        "optional": false,
        "description": "Minimum value (inclusive)"
      },
      {
        "name": "max",
        "type": "number",
        "optional": false,
        "description": "Maximum value (inclusive)"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensures number is within range",
        "code": "// Basic usage - ensures number is within range\r\nconst validator = Builder()\r\n  .use(numberRangePlugin)\r\n  .for<FormData>()\r\n  .v(\"age\", (b) => b.number.range(18, 65))\r\n  .v(\"percentage\", (b) => b.number.required().range(0, 100))\r\n  .build();\r\n\n// For ratings\r\nbuilder.v(\"rating\", b => b.number.range(1, 5).integer())\r\n\n// For temperature ranges\r\nbuilder.v(\"celsius\", b => b.number.range(-273.15, 100))"
      }
    ],
    "returns": "Validation function that returns true if number is within range"
  },
  {
    "functionName": "object",
    "displayName": "object",
    "category": "standard",
    "description": "Validates that a value is a plain object (not null, array, or other types)",
    "usage": ".v(\"data\", b => b.object.object())",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates that value is an object",
        "code": "// Basic usage - validates that value is an object\r\nconst validator = Builder()\r\n  .use(objectPlugin)\r\n  .for<FormData>()\r\n  .v(\"settings\", (b) => b.object.object())\r\n  .v(\"config\", (b) => b.object.required().object())\r\n  .build();\r\n\n// For nested object validation\r\nbuilder.v(\"data\", b => b.object.object())\r\n  .v(\"data.name\", b => b.string.required())\r\n  .v(\"data.age\", b => b.number.min(0))\r\n\n// Combined with required for mandatory objects\r\nbuilder.v(\"user\", b => b.object.required().object())"
      }
    ],
    "returns": "Validation function that returns true if value is a plain object"
  },
  {
    "functionName": "objectAdditionalProperties",
    "displayName": "additionalProperties",
    "category": "standard",
    "description": "Validates additional properties in objects according to JSON Schema additionalProperties rules",
    "usage": ".v(\"config\", b => b.object.additionalProperties({ type: \"string\", minLength: 1 }))",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "allowed",
        "type": "boolean | JSONSchema7",
        "optional": false,
        "description": "Whether additional properties are allowed or schema for validation"
      },
      {
        "name": "options",
        "type": "AdditionalPropertiesOptions",
        "optional": true,
        "description": "Configuration including allowed property names"
      }
    ],
    "examples": [
      {
        "title": "Strict mode - no additional properties allowed",
        "code": "// Strict mode - no additional properties allowed\r\nconst validator = Builder()\r\n  .use(objectAdditionalPropertiesPlugin)\r\n  .for<UserData>()\r\n  .v(\"user\", (b) => b.object.additionalProperties(false, {\r\n    allowedProperties: [\"name\", \"age\", \"email\"]\r\n  }))\r\n  .build();\r\n\n// With schema validation for additional properties\r\nbuilder.v(\"config\", b => b.object.additionalProperties({\r\n  type: \"string\",\r\n  minLength: 1\r\n}))"
      }
    ],
    "returns": "Validation function that validates additional properties according to rules"
  },
  {
    "functionName": "objectDependentRequired",
    "displayName": "dependentRequired",
    "category": "object",
    "description": "Validates that when certain properties exist, other properties become required",
    "usage": "builder.v(\"\", b => b.object.dependentRequired({",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "dependencies",
        "type": "Record<string, string[] | DependentRequiredSchema>",
        "optional": false,
        "description": "Property dependencies mapping"
      }
    ],
    "examples": [
      {
        "title": "Dependent required fields",
        "code": "// Dependent required fields\r\nconst validator = Builder()\r\n  .use(objectDependentRequiredPlugin)\r\n  .for<{ name?: string; first?: string; last?: string; }>()\r\n  .v(\"\", (b) => b.object.dependentRequired({\r\n    name: [\"first\", \"last\"],\r\n    credit_card: [\"billing_address\"]\r\n  }))\r\n  .build();\r\n\n// With custom error messages\r\nbuilder.v(\"\", b => b.object.dependentRequired({\r\n  email: { \r\n    required: [\"email_verified\"],\r\n    message: \"When email is provided, email_verified is required\"\r\n  }\r\n}))"
      }
    ],
    "returns": "Validation function that checks dependent required fields"
  },
  {
    "functionName": "objectDependentSchemas",
    "displayName": "dependentSchemas",
    "category": "object",
    "description": "Validates object with dependent schemas that apply when certain properties exist",
    "usage": "builder.v(\"field\", b => b.string.dependentSchemas(\"value\"))",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "schemas",
        "type": "Record<string, JSONSchema7 | SchemaValidator>",
        "optional": false,
        "description": "Property to schema mapping"
      }
    ],
    "examples": [
      {
        "title": "Dependent schemas validation",
        "code": "// Dependent schemas validation\r\nconst validator = Builder()\r\n  .use(objectDependentSchemasPlugin)\r\n  .for<{ creditCard?: string; billingAddress?: string; zipCode?: string; }>()\r\n  .v(\"\", (b) => b.object.dependentSchemas({\r\n    creditCard: {\r\n      properties: {\r\n        billingAddress: { type: \"string\", minLength: 10 },\r\n        zipCode: { type: \"string\", pattern: \"^[0-9]{5}$\" }\r\n      },\r\n      required: [\"billingAddress\", \"zipCode\"]\r\n    }\r\n  }))\r\n  .build();"
      }
    ],
    "returns": "Validation function that applies schemas when trigger properties exist"
  },
  {
    "functionName": "objectMaxProperties",
    "displayName": "maxProperties",
    "category": "standard",
    "description": "Validates that an object has at most the specified maximum number of properties",
    "usage": ".v(\"config\", b => b.object.maxProperties(3, { messageFactory: ({ path, params }) => `${path} can have at most ${params.max} properties` })",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "max",
        "type": "number",
        "optional": false,
        "description": "Maximum number of properties allowed"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensure object doesn't exceed maximum properties",
        "code": "// Basic usage - ensure object doesn't exceed maximum properties\r\nconst validator = Builder()\r\n  .use(objectMaxPropertiesPlugin)\r\n  .for<ConfigObject>()\r\n  .v(\"metadata\", (b) => b.object.maxProperties(5))\r\n  .v(\"settings\", (b) => b.object.maxProperties(10))\r\n  .build();\r\n\n// With custom error message\r\nbuilder.v(\"config\", b => b.object.maxProperties(3, {\r\n  messageFactory: ({ path, params }) =>\r\n    `${path} can have at most ${params.max} properties`\r\n}))"
      }
    ],
    "returns": "Validation function that returns true if object has at most maximum properties"
  },
  {
    "functionName": "objectMinProperties",
    "displayName": "minProperties",
    "category": "standard",
    "description": "Validates that an object has at least the specified minimum number of properties",
    "usage": ".v(\"config\", b => b.object.minProperties(3, { messageFactory: ({ path, params }) => `${path} must have at least ${params.min} properties` })",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "min",
        "type": "number",
        "optional": false,
        "description": "Minimum number of properties required"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - ensure object has minimum properties",
        "code": "// Basic usage - ensure object has minimum properties\r\nconst validator = Builder()\r\n  .use(objectMinPropertiesPlugin)\r\n  .for<ConfigObject>()\r\n  .v(\"metadata\", (b) => b.object.minProperties(2))\r\n  .v(\"settings\", (b) => b.object.minProperties(1))\r\n  .build();\r\n\n// With custom error message\r\nbuilder.v(\"config\", b => b.object.minProperties(3, {\r\n  messageFactory: ({ path, params }) =>\r\n    `${path} must have at least ${params.min} properties`\r\n}))"
      }
    ],
    "returns": "Validation function that returns true if object has at least minimum properties"
  },
  {
    "functionName": "objectPatternProperties",
    "displayName": "patternProperties",
    "category": "object",
    "description": "Validates object properties that match specific patterns with corresponding schemas",
    "usage": ".v(\"data\", b => b.object.patternProperties({ \"^email_\": { validator: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "patterns",
        "type": "Record<string, (value: any) => boolean | PatternValidator>",
        "optional": false,
        "description": "Pattern to validator mapping"
      }
    ],
    "examples": [
      {
        "title": "Pattern-based property validation",
        "code": "// Pattern-based property validation\r\nconst validator = Builder()\r\n  .use(objectPatternPropertiesPlugin)\r\n  .for<{ [key: string]: any }>()\r\n  .v(\"config\", (b) => b.object.patternProperties({\r\n    \"^str_\": (value) => typeof value === \"string\",\r\n    \"^num_\": (value) => typeof value === \"number\"\r\n  }))\r\n  .build();\r\n\n// With custom validators and messages\r\nbuilder.v(\"data\", b => b.object.patternProperties({\r\n  \"^email_\": {\r\n    validator: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\r\n    message: \"Email properties must be valid email addresses\"\r\n  },\r\n  \"^id_\": {\r\n    validator: (value) => typeof value === \"string\" && value.length > 0,\r\n    message: \"ID properties must be non-empty strings\"\r\n  }\r\n}))"
      }
    ],
    "returns": "Validation function that checks properties matching patterns"
  },
  {
    "functionName": "objectPropertyNames",
    "displayName": "propertyNames",
    "category": "object",
    "description": "Validates that all property names in an object match a specified pattern or schema",
    "usage": ".v(\"data\", b => b.object.propertyNames({ validator: (name) => name.length >= 3 && !name.startsWith('_')",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "schema",
        "type": "RegExp | string | { validator: (name: string) => boolean, message?: string }",
        "optional": false,
        "description": "Pattern or validation schema for property names"
      }
    ],
    "examples": [
      {
        "title": "Property names must match pattern",
        "code": "// Property names must match pattern\r\nconst validator = Builder()\r\n  .use(objectPropertyNamesPlugin)\r\n  .for<{ [key: string]: any }>()\r\n  .v(\"config\", (b) => b.object.propertyNames(/^[a-zA-Z_][a-zA-Z0-9_]*$/))\r\n  .build();\r\n\n// Property names with custom validator\r\nbuilder.v(\"data\", b => b.object.propertyNames({\r\n  validator: (name) => name.length >= 3 && !name.startsWith('_'),\r\n  message: \"Property names must be at least 3 characters and not start with underscore\"\r\n}))"
      }
    ],
    "returns": "Validation function that checks all property names"
  },
  {
    "functionName": "objectRecursively",
    "displayName": "recursively",
    "category": "standard",
    "description": "Applies validation rules recursively to nested fields or array elements",
    "usage": ".v(\"parent\", b => b.object.optional().recursively(\"__Self\")",
    "supportedTypes": [
      "object"
    ],
    "parameters": [
      {
        "name": "targetFieldPath",
        "type": "string | \"__Self\" | \"__Element\"",
        "optional": false,
        "description": "Special keywords or field path"
      },
      {
        "name": "options",
        "type": "{ maxDepth?: number }",
        "optional": true,
        "description": "Optional configuration for recursion depth"
      }
    ],
    "examples": [
      {
        "title": "Self-referential structure using __Self",
        "code": "// Self-referential structure using __Self\r\ntype TreeNode = {\r\n  id: string;\r\n  name: string;\r\n  value: number;\r\n  parent?: TreeNode;\r\n  left?: TreeNode;\r\n  right?: TreeNode;\r\n}\r\n\nconst validator = Builder()\r\n  .use(objectRecursivelyPlugin)\r\n  .for<TreeNode>()\r\n  .v(\"id\", b => b.string.required())\r\n  .v(\"name\", b => b.string.required().min(3))\r\n  .v(\"value\", b => b.number.required().min(0))\r\n  .v(\"parent\", b => b.object.optional().recursively(\"__Self\"))\r\n  .v(\"left\", b => b.object.optional().recursively(\"__Self\"))\r\n  .v(\"right\", b => b.object.optional().recursively(\"__Self\"))\r\n  .build();\r\n\n// Array elements using __Element\r\ntype Category = {\r\n  id: number;\r\n  name: string;\r\n  description?: string;\r\n  parentCategory?: Category;\r\n  subcategories: Category[];\r\n}\r\n\nconst categoryValidator = Builder()\r\n  .use(objectRecursivelyPlugin)\r\n  .for<Category>()\r\n  .v(\"id\", b => b.number.required().min(1))\r\n  .v(\"name\", b => b.string.required())\r\n  .v(\"description\", b => b.string.optional())\r\n  .v(\"parentCategory\", b => b.object.optional().recursively(\"__Self\"))\r\n  .v(\"subcategories\", b => b.array.required())\r\n  .v(\"subcategories[*]\", b => b.object.recursively(\"__Element\"))\r\n  .build();"
      }
    ],
    "returns": "Validation function that marks object for recursive validation"
  },
  {
    "functionName": "oneOf",
    "displayName": "oneOf",
    "category": "standard",
    "description": "Validates that a value is one of the specified allowed values (enum-like validation)",
    "usage": ".v(\"priority\", b => b.number.oneOf([0, 1, 2, 3]))",
    "supportedTypes": [
      "string",
      "number",
      "boolean"
    ],
    "parameters": [
      {
        "name": "allowed",
        "type": "Array<string | number | boolean>",
        "optional": false,
        "description": "Array of allowed values"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "String enum validation",
        "code": "// String enum validation\r\nconst validator = Builder()\r\n  .use(oneOfPlugin)\r\n  .for<FormData>()\r\n  .v(\"status\", (b) => b.string.oneOf([\"active\", \"inactive\", \"pending\"]))\r\n  .v(\"role\", (b) => b.string.oneOf([\"admin\", \"user\", \"guest\"]))\r\n  .build();\r\n\n// Number enum validation\r\nbuilder.v(\"priority\", b => b.number.oneOf([0, 1, 2, 3]))\r\n\n// With TypeScript const for type safety\r\nconst ROLES = [\"admin\", \"user\", \"guest\"] as const;\r\nbuilder.v(\"userRole\", b => b.string.oneOf(ROLES))"
      }
    ],
    "returns": "Validation function that returns true if value is in the allowed list"
  },
  {
    "functionName": "optional",
    "displayName": "optional",
    "category": "standard",
    "description": "Allows a field to be undefined (but not null or empty string)",
    "usage": ".v(\"hobbies\", b => b.array.optional().minLength(1)",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [],
    "examples": [
      {
        "title": "Basic usage - field can be undefined",
        "code": "// Basic usage - field can be undefined\r\nconst validator = Builder()\r\n  .use(optionalPlugin)\r\n  .for<UserProfile>()\r\n  .v(\"nickname\", (b) => b.string.optional().min(3))\r\n  .v(\"age\", (b) => b.number.optional().min(0))\r\n  .build();\r\n\n// Arrays and objects can be optional\r\nbuilder.v(\"hobbies\", b => b.array.optional().minLength(1))\r\nbuilder.v(\"settings\", b => b.object.optional())"
      }
    ],
    "returns": "Validation function that returns true and skips further validation if value is undefined"
  },
  {
    "functionName": "optionalIf",
    "displayName": "optionalIf",
    "category": "conditional",
    "description": "Makes a field optional based on a dynamic condition evaluated at validation time, with support for array context validation",
    "usage": ".v(\"field\", b => b.string.optionalIf(condition))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [
      {
        "name": "condition",
        "type": "(allValues: TObject, arrayContext?: ArrayContext) => boolean",
        "optional": false,
        "description": "Condition function that determines if field is optional, with access to array context"
      }
    ],
    "examples": [
      {
        "title": "Basic conditional optional",
        "code": "// Basic conditional optional\r\nconst validator = Builder()\r\n  .use(optionalIfPlugin)\r\n  .for<UserForm>()\r\n  .v(\"middleName\", (b) =>\r\n    b.string.optionalIf(values => !values.includeMiddleName).min(2)\r\n  )\r\n  .build();\r\n\n// Phone optional if email provided\r\nbuilder.v(\"phone\", b =>\r\n  b.string.optionalIf(values => !!values.email).pattern(/^\\d{10}$/)\r\n)"
      }
    ],
    "returns": "Validation function that skips validation when condition is true and value is empty"
  },
  {
    "functionName": "orFail",
    "displayName": "orFail",
    "category": "conditional",
    "description": "Conditionally forces validation to fail with a custom error message",
    "usage": ".v(\"field\", b => b.string.orFail(condition))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union",
      "tuple"
    ],
    "parameters": [
      {
        "name": "condition",
        "type": "(allValues: TObject) => boolean",
        "optional": false,
        "description": "Condition that determines if validation should fail"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration with custom message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - fails when condition is true",
        "code": "// Basic usage - fails when condition is true\r\nconst validator = Builder()\r\n  .use(orFailPlugin)\r\n  .for<FormData>()\r\n  .v(\"deprecated\", (b) => b.string.orFail(\r\n    values => values.useDeprecatedField === true,\r\n    { messageFactory: ({ path }) => `${path} is deprecated and should not be used` }\r\n  ))\r\n  .build();\r\n\n// Environment-based validation\r\nbuilder.v(\"debugData\", b =>\r\n  b.object.orFail(\r\n    values => values.environment === 'production',\r\n    { messageFactory: ({ path }) => `${path} should not be present in production` }\r\n  )\r\n)\r\n\n// Feature flag based\r\nbuilder.v(\"betaFeature\", b =>\r\n  b.string.orFail(\r\n    values => !values.betaEnabled,\r\n    { messageFactory: ({ path }) => `${path} requires beta features to be enabled` }\r\n  )\r\n)"
      }
    ],
    "returns": "Validation function that fails when condition is true"
  },
  {
    "functionName": "readOnlyWriteOnly",
    "displayName": "readOnlyWriteOnly",
    "category": "context",
    "description": "Validates fields based on read-only or write-only context",
    "usage": "builder.v(\"field\", b => b.string.readOnlyWriteOnly(..., \"value\"))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "date",
      "array",
      "object"
    ],
    "parameters": [
      {
        "name": "mode",
        "type": "\"readOnly\" | \"writeOnly\"",
        "optional": true,
        "description": "The access mode for the field"
      },
      {
        "name": "options",
        "type": "{ errorMessage?: string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Read-only field (should not be modified after creation)",
        "code": "// Read-only field (should not be modified after creation)\r\nconst validator = Builder()\r\n  .use(readOnlyWriteOnlyPlugin)\r\n  .for<{ id: string; name: string; }>()\r\n  .v(\"id\", (b) => b.string.readOnly())\r\n  .v(\"name\", (b) => b.string.required())\r\n  .build();\r\n\n// Write-only field (e.g., password that shouldn't be read back)\r\nbuilder.v(\"password\", b => b.string.writeOnly())\r\n\n// With operation context\r\nconst result = validator.validate(data, { \r\n  context: { operation: \"read\" } // or \"write\"\r\n});"
      }
    ],
    "returns": "Validation function that checks field access based on context"
  },
  {
    "functionName": "required",
    "displayName": "required",
    "category": "standard",
    "description": "Validates that a field is required (not null, undefined, or empty string)",
    "usage": ".v(\"email\", b => b.string.required({ messageFactory: ({ path }) => `${path} is required` })",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "date",
      "array",
      "object",
      "tuple",
      "union"
    ],
    "parameters": [
      {
        "name": "messageFactory",
        "type": "(context: MessageContext) => string",
        "optional": true,
        "description": "Custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage",
        "code": "// Basic usage\r\nconst validator = Builder()\r\n  .use(requiredPlugin)\r\n  .for<UserProfile>()\r\n  .v(\"name\", (b) => b.string.required())\r\n  .v(\"age\", (b) => b.number.required())\r\n  .v(\"terms\", (b) => b.boolean.required())\r\n  .build();\r\n\n// Custom error message\r\nbuilder.v(\"email\", b => b.string.required({\r\n  messageFactory: ({ path }) => `${path} is required`\r\n}))"
      }
    ],
    "returns": "Validation function that returns true if value exists (not null/undefined/empty string)"
  },
  {
    "functionName": "requiredIf",
    "displayName": "requiredIf",
    "category": "conditional",
    "description": "Makes a field required based on a dynamic condition evaluated at validation time, with support for array context validation",
    "usage": ".v(\"field\", b => b.string.requiredIf(condition))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [
      {
        "name": "condition",
        "type": "(allValues: TObject, arrayContext?: ArrayContext) => boolean",
        "optional": false,
        "description": "Condition function that receives all form values and optional array context"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic conditional required",
        "code": "// Basic conditional required\r\nconst validator = Builder()\r\n  .use(requiredIfPlugin)\r\n  .for<ContactForm>()\r\n  .v(\"email\", (b) => b.string.requiredIf(values => values.contactMethod === 'email'))\r\n  .v(\"phone\", (b) => b.string.requiredIf(values => values.contactMethod === 'phone'))\r\n  .build();\r\n\n// Multiple conditions\r\nbuilder.v(\"ssn\", b =>\r\n  b.string.requiredIf(values =>\r\n    values.country === 'US' && values.employmentType === 'full-time'\r\n  )\r\n)\r\n\n// Array context validation - conditional required within array items\r\nbuilder.v(\"items[].billingAddress\", b =>\r\n  b.string.requiredIf((allValues, arrayContext) => {\r\n    // arrayContext.index: current index in array\r\n    // arrayContext.item: current object at index\r\n    // arrayContext.array: full array\r\n    return arrayContext?.item?.type === 'premium';\r\n  })\r\n)\r\n\n// Mixed validation - access both form values and array context\r\nbuilder.v(\"orders[].shippingAddress\", b =>\r\n  b.string.requiredIf((allValues, arrayContext) => {\r\n    const isInternational = allValues.country !== 'US';\r\n    const requiresShipping = arrayContext?.item?.requiresShipping;\r\n    return isInternational && requiresShipping;\r\n  })\r\n)"
      }
    ],
    "returns": "Validation function that checks if field is required based on condition"
  },
  {
    "functionName": "skip",
    "displayName": "skip",
    "category": "conditional",
    "description": "Completely skips validation for a field based on a dynamic condition",
    "usage": ".v(\"field\", b => b.string.skip(condition))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [
      {
        "name": "condition",
        "type": "(allValues: TObject) => boolean",
        "optional": false,
        "description": "Function that returns true if field should be skipped"
      },
      {
        "name": "options",
        "type": "ValidationOptions",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Skip validation when not needed",
        "code": "// Skip validation when not needed\r\nconst validator = Builder()\r\n  .use(skipPlugin)\r\n  .for<FormData>()\r\n  .v(\"advancedOptions\", b =>\r\n    b.object\r\n      .skip(values => !values.showAdvanced)\r\n      .required()\r\n  )\r\n  .build();\r\n\n// Skip debug fields in production\r\nbuilder.v(\"debugInfo\", b =>\r\n  b.string\r\n    .skip(values => values.environment === 'production')\r\n    .min(10)\r\n)\r\n\n// Skip entire sections conditionally\r\nbuilder.v(\"enterpriseSettings\", b =>\r\n  b.object\r\n    .skip(values => values.plan !== 'enterprise')\r\n    .recursively()\r\n)"
      }
    ],
    "returns": "Validation function that skips field entirely when condition is true"
  },
  {
    "functionName": "stitch",
    "displayName": "stitch",
    "category": "multiFieldReference",
    "description": "Validates a field based on multiple other fields' values (cross-field validation) with full type safety",
    "usage": "builder.v(\"total\", (b) => b.number.required().stitch(",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "date",
      "object",
      "array",
      "tuple",
      "union"
    ],
    "parameters": [
      {
        "name": "fields",
        "type": "readonly (NestedKeyOf<TObject> & string)[]",
        "optional": false,
        "description": "Array of field paths to extract"
      },
      {
        "name": "validate",
        "type": "(fieldValues, currentValue, allValues) => ValidationResult",
        "optional": false,
        "description": "Validation function"
      },
      {
        "name": "options",
        "type": "{ code?, messageFactory? }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Type-safe date range validation",
        "code": "// Type-safe date range validation\r\ntype EventForm = {\r\n  startDate: string;\r\n  endDate: string;\r\n  eventDate: string;\r\n};\r\n\nconst validator = Builder()\r\n  .use(stitchPlugin)\r\n  .for<EventForm>()\r\n  .v(\"eventDate\", (b) => b.string.required().stitch(\r\n    [\"startDate\", \"endDate\"] as const, // First arg: field names\r\n    (fieldValues, eventDate) => {      // Second arg: validation function\r\n      // fieldValues: { startDate: string; endDate: string; } ← Type-safe!\r\n      // eventDate: string ← Current field's type\r\n\n      const event = new Date(eventDate);\r\n      const start = new Date(fieldValues.startDate);\r\n      const end = new Date(fieldValues.endDate);\r\n\n      return {\r\n        valid: event >= start && event <= end,\r\n        message: event < start\r\n          ? \"Event date cannot be before start date\"\r\n          : \"Event date cannot be after end date\"\r\n      };\r\n    }\r\n  ))\r\n  .build();\r\n\n// Price calculation with type-safe field access\r\ntype OrderForm = {\r\n  price: number;\r\n  quantity: number;\r\n  discount: number;\r\n  total: number;\r\n};\r\n\nbuilder.v(\"total\", (b) => b.number.required().stitch(\r\n  [\"price\", \"quantity\", \"discount\"] as const,\r\n  (fieldValues, total) => {\r\n    // fieldValues: { price: number; quantity: number; discount: number; }\r\n    const calculated = fieldValues.price * fieldValues.quantity * (1 - fieldValues.discount);\r\n    return {\r\n      valid: Math.abs(total - calculated) < 0.01,\r\n      message: `Expected ${calculated.toFixed(2)}, got ${total}`\r\n    };\r\n  },\r\n  { // Third arg: optional configuration\r\n    code: \"TOTAL_MISMATCH\",\r\n    messageFactory: ({ fieldValues, value }) =>\r\n      `Total ${value} doesn't match calculation`\r\n  }\r\n))"
      }
    ],
    "returns": "Type-safe validation function for multi-field validation"
  },
  {
    "functionName": "stringAlphanumeric",
    "displayName": "alphanumeric",
    "category": "standard",
    "description": "Validates that a string contains only alphanumeric characters (letters and numbers)",
    "usage": ".v(\"displayName\", b => b.string.alphanumeric(true))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "allowSpaces",
        "type": "boolean",
        "optional": true,
        "description": "Whether to allow spaces (default: false)"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - only letters and numbers allowed",
        "code": "// Basic usage - only letters and numbers allowed\r\nconst validator = Builder()\r\n  .use(stringAlphanumericPlugin)\r\n  .for<UserData>()\r\n  .v(\"username\", (b) => b.string.alphanumeric())\r\n  .v(\"userId\", (b) => b.string.required().alphanumeric())\r\n  .build();\r\n\n// Allow spaces in addition to alphanumeric characters\r\nbuilder.v(\"displayName\", b => b.string.alphanumeric(true))\r\n\n// Combined with length validation\r\nbuilder.v(\"productCode\", b => b.string.alphanumeric().min(3).max(20))"
      }
    ],
    "returns": "Validation function that returns true if string contains only allowed characters"
  },
  {
    "functionName": "stringBase64",
    "displayName": "stringBase64",
    "category": "string",
    "description": "Validates base64 encoded string",
    "usage": "builder.v(\"field\", b => b.string.stringBase64(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string; urlSafe?: boolean }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates base64 encoded string (RFC 4648 compliant)",
        "code": "// Basic usage - validates base64 encoded string (RFC 4648 compliant)\r\nconst validator = Builder()\r\n  .use(stringBase64Plugin)\r\n  .for<{ encodedData: string }>()\r\n  .v(\"encodedData\", (b) => b.string.base64())\r\n  .build();\r\n\n// URL-safe base64 validation\r\nconst urlSafeValidator = Builder()\r\n  .use(stringBase64Plugin)\r\n  .for<{ token: string }>()\r\n  .v(\"token\", (b) => b.string.base64({ urlSafe: true }))\r\n  .build();\r\n\n// ✅ VALID base64 strings (RFC 4648)\r\n// Standard base64 encoding\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ=\" });           // \"Hello World\"\r\nvalidator.parse({ encodedData: \"YW55IGNhcm5hbCBwbGVhc3VyZS4=\" }); // \"any carnal pleasure.\"\r\nvalidator.parse({ encodedData: \"\" });                          // Empty string\r\nvalidator.parse({ encodedData: \"YQ==\" });                      // Single char \"a\"\r\nvalidator.parse({ encodedData: \"YWI=\" });                      // Two chars \"ab\"\r\nvalidator.parse({ encodedData: \"YWJj\" });                      // Three chars \"abc\"\r\nvalidator.parse({ encodedData: \"YWJjZA==\" });                  // Four chars \"abcd\"\r\nvalidator.parse({ encodedData: \"VGhpcyBpcyBhIHRlc3Q=\" });       // \"This is a test\"\r\n\r\n// With numbers and special base64 characters\r\nvalidator.parse({ encodedData: \"MTIzNDU2Nzg5MA==\" });          // \"1234567890\"\r\nvalidator.parse({ encodedData: \"QUJDREVGRw==\" });              // \"ABCDEFG\"\r\nvalidator.parse({ encodedData: \"YWJjZGVmZ2hpams=\" });           // \"abcdefghijk\"\r\nvalidator.parse({ encodedData: \"Pz8/Pz8/Pz8=\" });              // Contains + and / chars\r\nvalidator.parse({ encodedData: \"+/+/+/+/+/+=\" });              // All special chars\r\n\r\n// Different padding scenarios\r\nvalidator.parse({ encodedData: \"YWI=\" });                      // One padding char\r\nvalidator.parse({ encodedData: \"YQ==\" });                      // Two padding chars\r\nvalidator.parse({ encodedData: \"YWJj\" });                      // No padding needed\r\nvalidator.parse({ encodedData: \"YWJjZA==\" });                  // Two padding chars\r\n\r\n// URL-safe base64 (RFC 4648 Section 5)\r\nurlSafeValidator.parse({ token: \"SGVsbG8gV29ybGQ\" });          // URL-safe without padding\r\nurlSafeValidator.parse({ token: \"SGVsbG8gV29ybGQ=\" });         // URL-safe with padding\r\nurlSafeValidator.parse({ token: \"YW55IGNhcm5hbC1wbGVhc3VyZS4\" }); // Uses - instead of /\r\nurlSafeValidator.parse({ token: \"YWJjZGVmZ2hpams_\" });         // Uses _ instead of +\r\nurlSafeValidator.parse({ token: \"-_-_-_-_-_-_\" });            // All URL-safe special chars\r\n\r\n// Real-world examples\r\nvalidator.parse({ encodedData: \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\" }); // JWT header\r\nvalidator.parse({ encodedData: \"VG8gYmUgb3Igbm90IHRvIGJlLCB0aGF0IGlzIHRoZSBxdWVzdGlvbg==\" }); // Long text\r\nvalidator.parse({ encodedData: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==\" }); // Base64 image\r\n\n// ❌ INVALID base64 strings\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ\" });          // Wrong length (not multiple of 4)\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ===\" });       // Too many padding chars (3)\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ====\" });      // Too many padding chars (4)\r\nvalidator.parse({ encodedData: \"SGV@bG8gV29ybGQ=\" });         // Invalid character (@)\r\nvalidator.parse({ encodedData: \"SGV sbG8gV29ybGQ=\" });        // Space not allowed\r\nvalidator.parse({ encodedData: \"SGV\\tbG8gV29ybGQ=\" });        // Tab not allowed\r\nvalidator.parse({ encodedData: \"SGV\\nbG8gV29ybGQ=\" });        // Newline not allowed\r\nvalidator.parse({ encodedData: \"SGVsbG8\\rgV29ybGQ=\" });       // Carriage return not allowed\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ=\" });         // Non-standard characters\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ!=\" });        // Exclamation mark not allowed\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ?=\" });        // Question mark not allowed\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ&=\" });        // Ampersand not allowed\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ*=\" });        // Asterisk not allowed\r\n\r\n// Padding in wrong position\r\nvalidator.parse({ encodedData: \"SGVsbG=gV29ybGQ=\" });         // Padding in middle\r\nvalidator.parse({ encodedData: \"=GVsbG8gV29ybGQ=\" });         // Padding at start\r\nvalidator.parse({ encodedData: \"SGVsbG8=V29ybGQ=\" });         // Padding before end\r\n\r\n// URL-safe base64 invalid examples\r\nurlSafeValidator.parse({ token: \"SGVsbG8gV29ybGQ+\" });        // + not allowed in URL-safe\r\nurlSafeValidator.parse({ token: \"SGVsbG8gV29ybGQ/\" });        // / not allowed in URL-safe\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ-\" });         // - not allowed in standard\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ_\" });         // _ not allowed in standard\r\n\r\n// Edge cases\r\nvalidator.parse({ encodedData: \" SGVsbG8gV29ybGQ=\" });        // Leading space\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ= \" });        // Trailing space\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ=\\n\" });       // Trailing newline\r\nvalidator.parse({ encodedData: \"SGVsbG8gV29ybGQ=\\r\\n\" });     // CRLF at end"
      }
    ],
    "returns": "Validation function that checks base64 encoding"
  },
  {
    "functionName": "stringContentEncoding",
    "displayName": "contentEncoding",
    "category": "string",
    "description": "Validates string content encoding (base64, base32, binary, etc.)",
    "usage": "builder.v(\"field\", b => b.string.contentEncoding(...))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "encoding",
        "type": "\"base64\" | \"base32\" | \"binary\" | \"7bit\" | \"8bit\" | \"quoted",
        "optional": false,
        "description": "printable\""
      }
    ],
    "examples": [
      {
        "title": "stringContentEncoding Example",
        "code": "const validator = Builder()\r\n  .use(stringContentEncodingPlugin)\r\n  .for<{ data: string }>()\r\n  .v(\"data\", (b) => b.string.contentEncoding(\"base64\"))\r\n  .build();\r\n\r\n// Valid for base64: SGVsbG8gV29ybGQ=\r\n// Valid for base32: JBSWY3DPEBLW64TMMQ======\r\n// Valid for binary: 01001000 01100101"
      }
    ],
    "returns": "Validation function that checks content encoding"
  },
  {
    "functionName": "stringContentMediaType",
    "displayName": "stringContentMediaType",
    "category": "string",
    "description": "Validates that a string's decoded content matches the specified media type",
    "usage": "builder.v(\"field\", b => b.string.stringContentMediaType(\"value\", \"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "mediaType",
        "type": "string",
        "optional": false,
        "description": "The expected media type"
      },
      {
        "name": "options",
        "type": "{ encoding?: string; messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "stringContentMediaType Example",
        "code": "const validator = Builder()\r\n  .use(stringContentMediaTypePlugin)\r\n  .for<{ data: string }>()\r\n  .v(\"data\", (b) => b.string.contentMediaType(\"application/json\"))\r\n  .build();\r\n\r\n// Valid: base64-encoded JSON\r\nvalidator.validate({ data: \"eyJrZXkiOiJ2YWx1ZSJ9\" }); // {\"key\":\"value\"}\r\n\r\n// Invalid: not valid JSON when decoded\r\nvalidator.validate({ data: \"aGVsbG8gd29ybGQ=\" }); // \"hello world\""
      }
    ],
    "returns": "Validation function that checks content media type"
  },
  {
    "functionName": "stringDate",
    "displayName": "date",
    "category": "string",
    "description": "Validates ISO 8601 date format (YYYY-MM-DD)",
    "usage": "builder.v(\"field\", b => b.string.date(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "stringDate Example",
        "code": "const validator = Builder()\r\n  .use(stringDatePlugin)\r\n  .for<{ birthDate: string }>()\r\n  .v(\"birthDate\", (b) => b.string.date())\r\n  .build();\r\n\r\n// Valid formats:\r\n// 2024-01-15\r\n// 2024-12-31\r\n// 2000-02-29 (leap year)\r\n\r\n// Invalid:\r\n// 2024-13-01 (invalid month)\r\n// 2024-02-30 (invalid day)\r\n// 2024-1-1 (must be zero-padded)"
      }
    ],
    "returns": "Validation function that checks ISO 8601 date format"
  },
  {
    "functionName": "stringDatetime",
    "displayName": "stringDatetime",
    "category": "string",
    "description": "Validates ISO 8601 datetime format with optional timezone support",
    "usage": "builder.v(\"field\", b => b.string.stringDatetime(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string; strict?: boolean }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates ISO 8601 datetime format (RFC 3339 compliant)",
        "code": "// Basic usage - validates ISO 8601 datetime format (RFC 3339 compliant)\r\nconst validator = Builder()\r\n  .use(stringDatetimePlugin)\r\n  .for<{ timestamp: string }>()\r\n  .v(\"timestamp\", (b) => b.string.datetime())\r\n  .build();\r\n\n// Strict mode - requires timezone\r\nconst strictValidator = Builder()\r\n  .use(stringDatetimePlugin)\r\n  .for<{ timestamp: string }>()\r\n  .v(\"timestamp\", (b) => b.string.datetime({ strict: true }))\r\n  .build();\r\n\r\n// ✅ VALID datetime formats (RFC 3339 / ISO 8601)\r\n// UTC timezone\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00Z\" });           // UTC with Z\r\nvalidator.parse({ timestamp: \"2024-12-31T23:59:59Z\" });           // End of year\r\nvalidator.parse({ timestamp: \"2000-01-01T00:00:00Z\" });           // Y2K date\r\n\r\n// With timezone offsets\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00+09:00\" });      // Japan timezone\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00-05:00\" });      // EST timezone\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00+00:00\" });      // UTC with offset\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00-12:00\" });      // Far west timezone\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00+14:00\" });      // Far east timezone\r\n\r\n// With milliseconds\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00.123Z\" });       // 3-digit milliseconds\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00.1Z\" });         // 1-digit milliseconds\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00.12Z\" });        // 2-digit milliseconds\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00.999+09:00\" });  // Max milliseconds with offset\r\n\r\n// Leap year dates\r\nvalidator.parse({ timestamp: \"2024-02-29T12:00:00Z\" });           // Valid leap day 2024\r\nvalidator.parse({ timestamp: \"2000-02-29T12:00:00Z\" });           // Valid leap day 2000\r\n\r\n// Edge cases\r\nvalidator.parse({ timestamp: \"2024-01-01T00:00:00Z\" });           // Start of year\r\nvalidator.parse({ timestamp: \"2024-12-31T23:59:59.999Z\" });       // End of year with ms\r\nvalidator.parse({ timestamp: \"1970-01-01T00:00:00Z\" });           // Unix epoch\r\nvalidator.parse({ timestamp: \"9999-12-31T23:59:59Z\" });           // Far future\r\n\r\n// Without timezone (lenient mode only)\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00\" });            // Local time (strict: false)\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00.123\" });        // Local time with ms\r\n\n// ❌ INVALID datetime formats\r\nvalidator.parse({ timestamp: \"invalid-datetime\" });               // Plain text\r\nvalidator.parse({ timestamp: \"2024-13-15T10:30:00Z\" });           // Invalid month (13)\r\nvalidator.parse({ timestamp: \"2024-00-15T10:30:00Z\" });           // Invalid month (0)\r\nvalidator.parse({ timestamp: \"2024-01-32T10:30:00Z\" });           // Invalid day (32)\r\nvalidator.parse({ timestamp: \"2024-01-00T10:30:00Z\" });           // Invalid day (0)\r\nvalidator.parse({ timestamp: \"2024-01-15T25:30:00Z\" });           // Invalid hour (25)\r\nvalidator.parse({ timestamp: \"2024-01-15T10:60:00Z\" });           // Invalid minute (60)\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:61Z\" });           // Invalid second (61)\r\nvalidator.parse({ timestamp: \"2024-02-30T10:30:00Z\" });           // Invalid day for February\r\nvalidator.parse({ timestamp: \"2023-02-29T10:30:00Z\" });           // Not a leap year\r\nvalidator.parse({ timestamp: \"2024-04-31T10:30:00Z\" });           // Invalid day for April\r\nvalidator.parse({ timestamp: \"2024-01-15 10:30:00Z\" });           // Space instead of T\r\nvalidator.parse({ timestamp: \"2024/01/15T10:30:00Z\" });           // Wrong date separator\r\nvalidator.parse({ timestamp: \"24-01-15T10:30:00Z\" });             // 2-digit year\r\nvalidator.parse({ timestamp: \"2024-1-15T10:30:00Z\" });            // Single-digit month\r\nvalidator.parse({ timestamp: \"2024-01-5T10:30:00Z\" });            // Single-digit day\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00\" });            // Missing timezone (strict: true)\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00+25:00\" });      // Invalid timezone offset\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00.1234Z\" });      // Too many milliseconds digits\r\nvalidator.parse({ timestamp: \"\" });                              // Empty string\r\nvalidator.parse({ timestamp: \"2024-01-15T10:30:00Z \" });          // Trailing space\r\nvalidator.parse({ timestamp: \" 2024-01-15T10:30:00Z\" });          // Leading space"
      }
    ],
    "returns": "Validation function that checks ISO 8601 datetime format"
  },
  {
    "functionName": "stringDuration",
    "displayName": "duration",
    "category": "string",
    "description": "Validates ISO 8601 duration format",
    "usage": "builder.v(\"field\", b => b.string.duration(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "stringDuration Example",
        "code": "const validator = Builder()\r\n  .use(stringDurationPlugin)\r\n  .for<{ duration: string }>()\r\n  .v(\"duration\", (b) => b.string.duration())\r\n  .build();\r\n\r\n// Valid: P3Y6M4DT12H30M5S (3 years, 6 months, 4 days, 12 hours, 30 minutes, 5 seconds)\r\n// Valid: PT1H30M (1 hour, 30 minutes)\r\n// Valid: P7D (7 days)"
      }
    ],
    "returns": "Validation function that checks ISO 8601 duration format"
  },
  {
    "functionName": "stringEmail",
    "displayName": "stringEmail",
    "category": "standard",
    "description": "Simple and fast email validation with domain restriction and custom regex support (RFC 5322 compliant)",
    "usage": "builder.v(\"field\", b => b.string.stringEmail(..., \"value\", ..., \"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "EmailValidationOptions",
        "optional": true,
        "description": "Simple email validation configuration"
      },
      {
        "name": "allowedDomains",
        "type": "string[]",
        "optional": true,
        "description": "Only allow emails from these domains (practical for corporate restrictions)"
      },
      {
        "name": "customRegex",
        "type": "RegExp",
        "optional": true,
        "description": "Custom regex to override basic validation (practical escape hatch)"
      },
      {
        "name": "messageFactory",
        "type": "(context: MessageContext) => string",
        "optional": true,
        "description": "Custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates email format (RFC 5322 compliant)",
        "code": "// Basic usage - validates email format (RFC 5322 compliant)\r\nconst validator = Builder()\r\n  .use(stringEmailPlugin)\r\n  .for<UserProfile>()\r\n  .v(\"email\", (b) => b.string.email())\r\n  .v(\"contactEmail\", (b) => b.string.required().email())\r\n  .build();\r\n\n// Domain restriction (practical: corporate email only)\r\nbuilder.v(\"workEmail\", b => b.string.required().email({\r\n  allowedDomains: [\"company.com\", \"subsidiary.co.jp\"]\r\n}))\r\n\n// Custom regex for specific format requirements\r\nbuilder.v(\"strictEmail\", b => b.string.email({\r\n  customRegex: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\r\n}))\r\n\n// For length limits, use existing string plugins:\r\nbuilder.v(\"email\", b => b.string.required().max(100).email())\r\n\n// ✅ VALID email formats (RFC 5322)\r\nvalidator.parse({ email: \"user@example.com\" });              // Standard format\r\nvalidator.parse({ email: \"test.email+tag@domain.co.uk\" });   // With plus and dots\r\nvalidator.parse({ email: \"user123@test-server.com\" });       // Numbers and hyphens\r\nvalidator.parse({ email: \"firstname.lastname@example.org\" }); // Multiple dots\r\nvalidator.parse({ email: \"user+filter@gmail.com\" });         // Plus addressing\r\nvalidator.parse({ email: \"a@b.co\" });                        // Minimal valid\r\nvalidator.parse({ email: \"test_email@domain-name.com\" });     // Underscores and hyphens\r\n\r\n// ❌ INVALID email formats\r\nvalidator.parse({ email: \"plainaddress\" });          // No @ symbol\r\nvalidator.parse({ email: \"@missingdomain.com\" });    // Missing local part\r\nvalidator.parse({ email: \"missing.domain@\" });       // Missing domain\r\nvalidator.parse({ email: \"spaces @domain.com\" });    // Spaces not allowed\r\nvalidator.parse({ email: \"user@.com\" });             // Invalid domain start\r\nvalidator.parse({ email: \"user@domain\" });           // Missing TLD\r\nvalidator.parse({ email: \"user@@domain.com\" });      // Double @ symbol\r\nvalidator.parse({ email: \"user@domain..com\" });      // Double dots in domain\r\nvalidator.parse({ email: \".user@domain.com\" });      // Leading dot\r\nvalidator.parse({ email: \"user.@domain.com\" });      // Trailing dot"
      }
    ],
    "returns": "Validation function optimized for performance - regex validation with optional domain filtering or custom regex"
  },
  {
    "functionName": "stringEndsWith",
    "displayName": "endsWith",
    "category": "standard",
    "description": "Validates that a string ends with a specific suffix",
    "usage": ".v(\"document\", b => b.string.endsWith(\".pdf\").min(5)",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "suffix",
        "type": "string",
        "optional": false,
        "description": "The suffix that the string must end with"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - checks if string ends with suffix",
        "code": "// Basic usage - checks if string ends with suffix\r\nconst validator = Builder()\r\n  .use(stringEndsWithPlugin)\r\n  .for<FileData>()\r\n  .v(\"filename\", (b) => b.string.endsWith(\".pdf\"))\r\n  .v(\"configFile\", (b) => b.string.required().endsWith(\".json\"))\r\n  .build();\r\n\n// For file extension validation\r\nbuilder.v(\"document\", b => b.string.endsWith(\".pdf\").min(5))\r\n\n// Email domain validation\r\nbuilder.v(\"email\", b => b.string.email().endsWith(\"@company.com\"))"
      }
    ],
    "returns": "Validation function that returns true if string ends with the suffix"
  },
  {
    "functionName": "stringExactLength",
    "displayName": "exactLength",
    "category": "standard",
    "description": "Validates that a string has exactly the specified length",
    "usage": ".v(\"productCode\", b => b.string.exactLength(8).alphanumeric()",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "expectedLength",
        "type": "number",
        "optional": false,
        "description": "The exact length the string must have"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - requires exact string length",
        "code": "// Basic usage - requires exact string length\r\nconst validator = Builder()\r\n  .use(stringExactLengthPlugin)\r\n  .for<FormData>()\r\n  .v(\"zipCode\", (b) => b.string.exactLength(5))\r\n  .v(\"countryCode\", (b) => b.string.required().exactLength(2))\r\n  .build();\r\n\n// For product codes or SKUs\r\nbuilder.v(\"productCode\", b => b.string.exactLength(8).alphanumeric())\r\n\n// For fixed-format phone extensions\r\nbuilder.v(\"extension\", b => b.string.optional().exactLength(4))"
      }
    ],
    "returns": "Validation function that returns true if string has exact length"
  },
  {
    "functionName": "stringHostname",
    "displayName": "stringHostname",
    "category": "string",
    "description": "Validates hostname format (RFC 1123)",
    "usage": "builder.v(\"field\", b => b.string.stringHostname(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates hostname format (RFC 1123 compliant)",
        "code": "// Basic usage - validates hostname format (RFC 1123 compliant)\r\nconst validator = Builder()\r\n  .use(stringHostnamePlugin)\r\n  .for<{ hostname: string }>()\r\n  .v(\"hostname\", (b) => b.string.hostname())\r\n  .build();\r\n\n// ✅ VALID hostnames (RFC 1123)\r\nvalidator.parse({ hostname: \"example.com\" });                 // Standard domain\r\nvalidator.parse({ hostname: \"www.example.com\" });             // Subdomain\r\nvalidator.parse({ hostname: \"mail-server.company.org\" });     // With hyphens\r\nvalidator.parse({ hostname: \"a.b.c\" });                      // Short labels\r\nvalidator.parse({ hostname: \"host123.domain.co.uk\" });        // With numbers\r\nvalidator.parse({ hostname: \"localhost\" });                  // Single label\r\nvalidator.parse({ hostname: \"api-v2.service.internal\" });     // Multiple hyphens\r\nvalidator.parse({ hostname: \"test\" });                       // Single word\r\nvalidator.parse({ hostname: \"1a.2b.3c\" });                   // Starting with numbers\r\nvalidator.parse({ hostname: \"x\" });                          // Single character\r\nvalidator.parse({ hostname: \"sub.domain.example.com\" });      // Multiple levels\r\nvalidator.parse({ hostname: \"ftp.files.company-name.org\" });  // Complex structure\r\nvalidator.parse({ hostname: \"db1.cluster.production\" });      // Database naming\r\nvalidator.parse({ hostname: \"web01.dmz.corp\" });             // Network zones\r\nvalidator.parse({ hostname: \"backup-server.it.department\" }); // Organizational\r\n\r\n// Edge cases\r\nvalidator.parse({ hostname: \"a\".repeat(63) });               // Max label length (63 chars)\r\nvalidator.parse({ hostname: \"a\".repeat(63) + \".\" + \"b\".repeat(63) }); // Multiple max labels\r\nvalidator.parse({ hostname: \"0\" });                          // Single digit\r\nvalidator.parse({ hostname: \"9a\" });                         // Number followed by letter\r\n\n// ❌ INVALID hostnames\r\nvalidator.parse({ hostname: \"-example.com\" });               // Starting with hyphen\r\nvalidator.parse({ hostname: \"example-.com\" });               // Label ending with hyphen\r\nvalidator.parse({ hostname: \"example.com-\" });               // Hostname ending with hyphen  \r\nvalidator.parse({ hostname: \".example.com\" });               // Starting with dot\r\nvalidator.parse({ hostname: \"example..com\" });               // Double dot (empty label)\r\nvalidator.parse({ hostname: \"example.com.\" });               // Trailing dot\r\nvalidator.parse({ hostname: \"\" });                          // Empty string\r\nvalidator.parse({ hostname: \"example .com\" });               // Space in hostname\r\nvalidator.parse({ hostname: \"example_com\" });                // Underscore not allowed\r\nvalidator.parse({ hostname: \"EXAMPLE.COM\" });                // All caps (valid but not recommended)\r\nvalidator.parse({ hostname: \"example.com/path\" });           // With path\r\nvalidator.parse({ hostname: \"example.com:8080\" });           // With port\r\nvalidator.parse({ hostname: \"user@example.com\" });           // With user\r\nvalidator.parse({ hostname: \"http://example.com\" });         // Full URL\r\nvalidator.parse({ hostname: \"192.168.1.1\" });               // IP address (not hostname)\r\nvalidator.parse({ hostname: \"[::1]\" });                     // IPv6 address\r\n\r\n// Label too long (> 63 characters)\r\nvalidator.parse({ hostname: \"a\".repeat(64) + \".com\" });      // Single label > 63 chars\r\n\r\n// Hostname too long (> 253 characters total)\r\nconst longLabel = \"a\".repeat(50);\r\nconst longHostname = Array(10).fill(longLabel).join(\".\") + \".com\"; // > 253 chars total\r\nvalidator.parse({ hostname: longHostname });\r\n\r\n// Special characters not allowed\r\nvalidator.parse({ hostname: \"exam@ple.com\" });               // @ symbol\r\nvalidator.parse({ hostname: \"exam#ple.com\" });               // # symbol\r\nvalidator.parse({ hostname: \"exam$ple.com\" });               // $ symbol\r\nvalidator.parse({ hostname: \"exam%ple.com\" });               // % symbol\r\nvalidator.parse({ hostname: \"exam&ple.com\" });               // & symbol\r\nvalidator.parse({ hostname: \"example.com!\" });               // Exclamation mark\r\nvalidator.parse({ hostname: \"example.com?\" });               // Question mark\r\n\r\n// Unicode/international domain names (IDN not supported in basic hostname)\r\nvalidator.parse({ hostname: \"ドメイン.com\" });                // Japanese characters\r\nvalidator.parse({ hostname: \"münchen.de\" });                // German umlaut\r\nvalidator.parse({ hostname: \"café.fr\" });                   // French accent"
      }
    ],
    "returns": "Validation function that checks hostname format"
  },
  {
    "functionName": "stringIpv4",
    "displayName": "stringIpv4",
    "category": "string",
    "description": "Validates IPv4 address format",
    "usage": "builder.v(\"field\", b => b.string.stringIpv4(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates IPv4 address format (RFC 791 compliant)",
        "code": "// Basic usage - validates IPv4 address format (RFC 791 compliant)\r\nconst validator = Builder()\r\n  .use(stringIpv4Plugin)\r\n  .for<{ ipAddress: string }>()\r\n  .v(\"ipAddress\", (b) => b.string.ipv4())\r\n  .build();\r\n\n// ✅ VALID IPv4 addresses (RFC 791)\r\nvalidator.parse({ ipAddress: \"192.168.1.1\" });        // Private network (Class C)\r\nvalidator.parse({ ipAddress: \"127.0.0.1\" });          // Localhost/loopback\r\nvalidator.parse({ ipAddress: \"8.8.8.8\" });            // Google DNS\r\nvalidator.parse({ ipAddress: \"0.0.0.0\" });            // All zeros (any address)\r\nvalidator.parse({ ipAddress: \"255.255.255.255\" });    // Broadcast address\r\nvalidator.parse({ ipAddress: \"10.0.0.1\" });           // Private network (Class A)\r\nvalidator.parse({ ipAddress: \"172.16.0.1\" });         // Private network (Class B)\r\nvalidator.parse({ ipAddress: \"203.0.113.1\" });        // Documentation/test network\r\nvalidator.parse({ ipAddress: \"1.1.1.1\" });            // Cloudflare DNS\r\nvalidator.parse({ ipAddress: \"192.0.2.146\" });        // Documentation network\r\nvalidator.parse({ ipAddress: \"198.51.100.1\" });       // Documentation network\r\nvalidator.parse({ ipAddress: \"169.254.1.1\" });        // Link-local address\r\nvalidator.parse({ ipAddress: \"224.0.0.1\" });          // Multicast address\r\nvalidator.parse({ ipAddress: \"239.255.255.255\" });    // Local multicast\r\nvalidator.parse({ ipAddress: \"1.2.3.4\" });            // Simple valid address\r\nvalidator.parse({ ipAddress: \"100.64.0.1\" });         // Carrier-grade NAT\r\n\n// ❌ INVALID IPv4 addresses\r\nvalidator.parse({ ipAddress: \"256.1.1.1\" });          // Octet > 255\r\nvalidator.parse({ ipAddress: \"192.168.1.256\" });      // Last octet > 255\r\nvalidator.parse({ ipAddress: \"300.300.300.300\" });    // All octets > 255\r\nvalidator.parse({ ipAddress: \"192.168.1\" });          // Missing octet\r\nvalidator.parse({ ipAddress: \"192.168\" });            // Only 2 octets\r\nvalidator.parse({ ipAddress: \"192\" });                // Only 1 octet\r\nvalidator.parse({ ipAddress: \"192.168.1.1.1\" });      // Extra octet (5 octets)\r\nvalidator.parse({ ipAddress: \"192.168.01.1\" });       // Leading zeros (octal notation)\r\nvalidator.parse({ ipAddress: \"192.168.001.1\" });      // Multiple leading zeros\r\nvalidator.parse({ ipAddress: \"192.168.-1.1\" });       // Negative number\r\nvalidator.parse({ ipAddress: \"192.168.1.-1\" });       // Negative last octet\r\nvalidator.parse({ ipAddress: \"not.an.ip.address\" });  // Non-numeric text\r\nvalidator.parse({ ipAddress: \"192.168.1.1/24\" });     // CIDR notation\r\nvalidator.parse({ ipAddress: \"192.168.1.1:8080\" });   // With port number\r\nvalidator.parse({ ipAddress: \"192.168.1.\" });         // Trailing dot\r\nvalidator.parse({ ipAddress: \".192.168.1.1\" });       // Leading dot\r\nvalidator.parse({ ipAddress: \"192..168.1.1\" });       // Double dot\r\nvalidator.parse({ ipAddress: \"192 168 1 1\" });        // Spaces instead of dots\r\nvalidator.parse({ ipAddress: \"192,168,1,1\" });        // Commas instead of dots\r\nvalidator.parse({ ipAddress: \"192-168-1-1\" });        // Hyphens instead of dots\r\nvalidator.parse({ ipAddress: \"\" });                   // Empty string\r\nvalidator.parse({ ipAddress: \"192.168.1.1 \" });       // Trailing space\r\nvalidator.parse({ ipAddress: \" 192.168.1.1\" });       // Leading space\r\nvalidator.parse({ ipAddress: \"192.168.a.1\" });        // Letter in octet\r\nvalidator.parse({ ipAddress: \"192.168.1.1.\" });       // Trailing dot after last octet"
      }
    ],
    "returns": "Validation function that checks IPv4 format"
  },
  {
    "functionName": "stringIpv6",
    "displayName": "stringIpv6",
    "category": "string",
    "description": "Validates IPv6 address format",
    "usage": "builder.v(\"field\", b => b.string.stringIpv6(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates IPv6 address format (RFC 4291 compliant)",
        "code": "// Basic usage - validates IPv6 address format (RFC 4291 compliant)\r\nconst validator = Builder()\r\n  .use(stringIpv6Plugin)\r\n  .for<{ ipv6Address: string }>()\r\n  .v(\"ipv6Address\", (b) => b.string.ipv6())\r\n  .build();\r\n\n// ✅ VALID IPv6 addresses (RFC 4291)\r\n// Full format (128-bit address)\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" });\r\nvalidator.parse({ ipv6Address: \"2001:0DB8:85A3:0000:0000:8A2E:0370:7334\" }); // Case insensitive\r\n\r\n// Leading zeros omitted\r\nvalidator.parse({ ipv6Address: \"2001:db8:85a3:0:0:8a2e:370:7334\" });\r\nvalidator.parse({ ipv6Address: \"2001:db8:85a3:1:1:8a2e:370:7334\" });\r\n\r\n// Compressed format with :: (consecutive zeros)\r\nvalidator.parse({ ipv6Address: \"2001:db8:85a3::8a2e:370:7334\" });\r\nvalidator.parse({ ipv6Address: \"2001:db8::1\" });\r\nvalidator.parse({ ipv6Address: \"2001:db8::\" });\r\nvalidator.parse({ ipv6Address: \"::2001:db8:85a3:0:0:8a2e:370:7334\" });\r\nvalidator.parse({ ipv6Address: \"2001:db8:85a3:0:0:8a2e::\" });\r\n\r\n// Special addresses\r\nvalidator.parse({ ipv6Address: \"::1\" });                    // IPv6 loopback\r\nvalidator.parse({ ipv6Address: \"::\" });                     // All zeros (unspecified)\r\nvalidator.parse({ ipv6Address: \"::ffff:0:0\" });             // IPv4-mapped prefix\r\nvalidator.parse({ ipv6Address: \"::ffff:192.0.2.1\" });       // IPv4-mapped IPv6\r\nvalidator.parse({ ipv6Address: \"::ffff:c000:0201\" });       // IPv4-mapped (hex format)\r\nvalidator.parse({ ipv6Address: \"2001:db8::192.0.2.1\" });    // IPv4 suffix notation\r\n\r\n// Link-local addresses\r\nvalidator.parse({ ipv6Address: \"fe80::1\" });                // Link-local\r\nvalidator.parse({ ipv6Address: \"fe80::1%lo0\" });            // With zone identifier\r\nvalidator.parse({ ipv6Address: \"fe80::1%eth0\" });           // With interface name\r\nvalidator.parse({ ipv6Address: \"fe80::200:f8ff:fe21:67cf%en0\" }); // Full link-local with zone\r\n\r\n// Multicast addresses\r\nvalidator.parse({ ipv6Address: \"ff02::1\" });                // All nodes multicast\r\nvalidator.parse({ ipv6Address: \"ff02::2\" });                // All routers multicast\r\n\r\n// Documentation addresses\r\nvalidator.parse({ ipv6Address: \"2001:db8::1\" });            // Documentation prefix\r\nvalidator.parse({ ipv6Address: \"2001:db8:85a3::8a2e:370:7334\" }); // RFC 3849 example\r\n\r\n// Edge cases\r\nvalidator.parse({ ipv6Address: \"1:2:3:4:5:6:7:8\" });        // All single digits\r\nvalidator.parse({ ipv6Address: \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\" }); // All ones\r\n\n// ❌ INVALID IPv6 addresses\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3::8a2e::7334\" });        // Double :: (not allowed)\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:7334:extra\" }); // Too many groups\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370\" }); // Too few groups without ::\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:733g\" }); // Invalid hex char (g)\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:73345\" }); // Group too long (5 chars)\r\nvalidator.parse({ ipv6Address: \"2001::db8::85a3\" });                   // Multiple :: not allowed\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:\" }); // Trailing colon\r\nvalidator.parse({ ipv6Address: \":2001:0db8:85a3:0000:0000:8a2e:0370:7334\" }); // Leading colon (not ::)\r\nvalidator.parse({ ipv6Address: \"2001-0db8-85a3-0000-0000-8a2e-0370-7334\" }); // Hyphens instead of colons\r\nvalidator.parse({ ipv6Address: \"2001.0db8.85a3.0000.0000.8a2e.0370.7334\" }); // Dots instead of colons\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:7334/64\" }); // With CIDR notation\r\nvalidator.parse({ ipv6Address: \"gggg::1\" });                           // Invalid hex chars\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:::8a2e:0370:7334\" });   // Triple colon\r\nvalidator.parse({ ipv6Address: \"\" });                                  // Empty string\r\nvalidator.parse({ ipv6Address: \"not:an:ipv6:address\" });               // Non-hex text\r\nvalidator.parse({ ipv6Address: \"2001:0db8:85a3:0000:0000:8a2e:0370:7334 \" }); // Trailing space\r\nvalidator.parse({ ipv6Address: \" 2001:0db8:85a3:0000:0000:8a2e:0370:7334\" }); // Leading space\r\nvalidator.parse({ ipv6Address: \"::ffff:256.1.1.1\" });                 // Invalid IPv4 in mapping\r\nvalidator.parse({ ipv6Address: \"::ffff:192.168.1\" });                 // Incomplete IPv4 in mapping\r\nvalidator.parse({ ipv6Address: \"192.168.1.1\" });                      // Plain IPv4 address"
      }
    ],
    "returns": "Validation function that checks IPv6 format"
  },
  {
    "functionName": "stringIri",
    "displayName": "stringIri",
    "category": "string",
    "description": "Validates IRI (Internationalized Resource Identifier) format (RFC 3987)",
    "usage": "builder.v(\"field\", b => b.string.stringIri(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates IRI format (RFC 3987 compliant)",
        "code": "// Basic usage - validates IRI format (RFC 3987 compliant)\r\nconst validator = Builder()\r\n  .use(stringIriPlugin)\r\n  .for<{ identifier: string }>()\r\n  .v(\"identifier\", (b) => b.string.iri())\r\n  .build();\r\n\n// ✅ VALID IRI formats (RFC 3987)\r\n// Standard ASCII URIs (subset of IRI)\r\nvalidator.parse({ identifier: \"https://www.example.com/path\" });    // Regular HTTP URL\r\nvalidator.parse({ identifier: \"http://example.org:8080/api/v1\" }); // With port and path\r\nvalidator.parse({ identifier: \"ftp://files.example.com/file.txt\" }); // FTP scheme\r\nvalidator.parse({ identifier: \"mailto:user@example.com\" });         // Email scheme\r\nvalidator.parse({ identifier: \"tel:+1-555-123-4567\" });            // Telephone scheme\r\n\r\n// Internationalized domain names and paths (Unicode)\r\nvalidator.parse({ identifier: \"https://例え.jp/パス\" });              // Japanese characters\r\nvalidator.parse({ identifier: \"http://münchen.de/straße\" });       // German umlauts\r\nvalidator.parse({ identifier: \"https://café.fr/menu\" });           // French accents\r\nvalidator.parse({ identifier: \"http://домен.рф/путь\" });           // Cyrillic script\r\nvalidator.parse({ identifier: \"https://测试.cn/路径\" });             // Chinese characters\r\nvalidator.parse({ identifier: \"http://테스트.kr/경로\" });             // Korean characters\r\nvalidator.parse({ identifier: \"https://тест.bg/път\" });            // Bulgarian Cyrillic\r\nvalidator.parse({ identifier: \"http://δοκιμή.gr/διαδρομή\" });      // Greek characters\r\nvalidator.parse({ identifier: \"https://परीक्षा.in/पथ\" });           // Hindi/Devanagari\r\nvalidator.parse({ identifier: \"http://اختبار.sa/مسار\" });           // Arabic script\r\n\r\n// Internationalized email addresses\r\nvalidator.parse({ identifier: \"mailto:ユーザー@例え.jp\" });          // Japanese email\r\nvalidator.parse({ identifier: \"mailto:utilisateur@café.fr\" });     // French domain\r\nvalidator.parse({ identifier: \"mailto:пользователь@домен.рф\" });    // Cyrillic email\r\n\r\n// Mixed ASCII and Unicode\r\nvalidator.parse({ identifier: \"https://api.例え.jp/v1/users\" });    // Mixed path\r\nvalidator.parse({ identifier: \"https://例え.example.com/path\" });   // Mixed domain\r\nvalidator.parse({ identifier: \"ftp://files.café.com/données.txt\" }); // Mixed filename\r\n\r\n// Various schemes with Unicode\r\nvalidator.parse({ identifier: \"ldap://服务器.com/cn=用户,dc=例子,dc=com\" }); // LDAP with Chinese\r\nvalidator.parse({ identifier: \"news://nieuws.nl/groep.测试\" });     // News with mixed Unicode\r\nvalidator.parse({ identifier: \"urn:isbn:978-3-86680-192-9\" });     // URN (ASCII)\r\n\r\n// Edge cases\r\nvalidator.parse({ identifier: \"custom-scheme://测试.example/路径\" }); // Custom scheme with Unicode\r\nvalidator.parse({ identifier: \"x-proprietary://例え.internal\" });   // Non-standard scheme\r\nvalidator.parse({ identifier: \"data:text/plain;charset=utf-8,你好\" }); // Data URI with Unicode\r\n\n// ❌ INVALID IRI formats\r\nvalidator.parse({ identifier: \"not-an-iri\" });                     // No scheme separator\r\nvalidator.parse({ identifier: \"://missing-scheme.com\" });          // Missing scheme\r\nvalidator.parse({ identifier: \"http://\" });                        // Missing authority\r\nvalidator.parse({ identifier: \"https:/\" });                        // Malformed scheme separator\r\nvalidator.parse({ identifier: \"\" });                              // Empty string\r\nvalidator.parse({ identifier: \"http://exam ple.com\" });            // Space in authority\r\nvalidator.parse({ identifier: \"https://example.com/path with spaces\" }); // Spaces in path\r\nvalidator.parse({ identifier: \"http://example.com/path\\twith\\ttabs\" }); // Tab characters\r\nvalidator.parse({ identifier: \"https://example.com/path\\nwith\\nnewlines\" }); // Newline characters\r\nvalidator.parse({ identifier: \"http://example.com/path\\rwith\\rcarriage\" }); // Carriage returns\r\nvalidator.parse({ identifier: \"ftp://example.com\\x00null\" });      // Null character (control char)\r\nvalidator.parse({ identifier: \"https://example.com\\x01control\" }); // Control character\r\nvalidator.parse({ identifier: \"http://example.com\\x7Fdel\" });      // DEL character\r\n\r\n// Malformed schemes\r\nvalidator.parse({ identifier: \"123://invalid-scheme.com\" });       // Scheme starting with number\r\nvalidator.parse({ identifier: \"-http://invalid-scheme.com\" });     // Scheme starting with hyphen\r\nvalidator.parse({ identifier: \".http://invalid-scheme.com\" });     // Scheme starting with dot\r\nvalidator.parse({ identifier: \"ht@tp://invalid-char.com\" });       // Invalid char in scheme\r\nvalidator.parse({ identifier: \"ht tp://space-in-scheme.com\" });    // Space in scheme\r\n\r\n// Missing or empty components\r\nvalidator.parse({ identifier: \"http:\" });                          // Scheme only\r\nvalidator.parse({ identifier: \":\" });                             // Just separator\r\nvalidator.parse({ identifier: \"http://example.com:\" });           // Trailing colon\r\n\r\n// Invalid Unicode sequences (rare but possible)\r\nvalidator.parse({ identifier: \"https://example.com/\\uFFFD\" });     // Replacement character\r\nvalidator.parse({ identifier: \"http://\\uFEFF.example.com\" });      // BOM character\r\n\r\n// Leading/trailing whitespace\r\nvalidator.parse({ identifier: \" https://example.com\" });          // Leading space\r\nvalidator.parse({ identifier: \"https://example.com \" });          // Trailing space\r\nvalidator.parse({ identifier: \"\\thttps://example.com\" });         // Leading tab\r\nvalidator.parse({ identifier: \"https://example.com\\n\" });         // Trailing newline"
      }
    ],
    "returns": "Validation function that checks IRI format"
  },
  {
    "functionName": "stringIriReference",
    "displayName": "iriReference",
    "category": "string",
    "description": "Validates IRI-reference format (RFC 3987) - can be absolute or relative",
    "usage": "builder.v(\"field\", b => b.string.iriReference(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "stringIriReference Example",
        "code": "const validator = Builder()\r\n  .use(stringIriReferencePlugin)\r\n  .for<{ ref: string }>()\r\n  .v(\"ref\", (b) => b.string.iriReference())\r\n  .build();\r\n\r\n// Valid: https://example.com/path\r\n// Valid: /relative/path\r\n// Valid: ../parent\r\n// Valid: #fragment\r\n// Valid: ?query=param"
      }
    ],
    "returns": "Validation function that checks IRI-reference format"
  },
  {
    "functionName": "stringJsonPointer",
    "displayName": "stringJsonPointer",
    "category": "string",
    "description": "Validates JSON Pointer format (RFC 6901)",
    "usage": "builder.v(\"field\", b => b.string.stringJsonPointer(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates JSON Pointer format (RFC 6901 compliant)",
        "code": "// Basic usage - validates JSON Pointer format (RFC 6901 compliant)\r\nconst validator = Builder()\r\n  .use(stringJsonPointerPlugin)\r\n  .for<{ pointer: string }>()\r\n  .v(\"pointer\", (b) => b.string.jsonPointer())\r\n  .build();\r\n\n// ✅ VALID JSON Pointers (RFC 6901)\r\nvalidator.parse({ pointer: \"\" });                    // Empty string (points to root document)\r\nvalidator.parse({ pointer: \"/\" });                   // Points to empty property name\r\nvalidator.parse({ pointer: \"/foo\" });                // Simple property access\r\nvalidator.parse({ pointer: \"/foo/bar\" });            // Nested property access\r\nvalidator.parse({ pointer: \"/foo/0\" });              // Array element by index\r\nvalidator.parse({ pointer: \"/foo/0/bar\" });          // Property of array element\r\nvalidator.parse({ pointer: \"/users/123/name\" });     // Deep nested access\r\nvalidator.parse({ pointer: \"/data/items/0/id\" });    // Array element property\r\n\r\n// Escaped characters (RFC 6901 escape sequences)\r\nvalidator.parse({ pointer: \"/~0\" });                 // Escaped ~ character (represents \"~\")\r\nvalidator.parse({ pointer: \"/~1\" });                 // Escaped / character (represents \"/\")\r\nvalidator.parse({ pointer: \"/~0~1\" });               // Both escapes (represents \"~/\")\r\nvalidator.parse({ pointer: \"/foo~1bar\" });           // Forward slash escaped in middle\r\nvalidator.parse({ pointer: \"/~0field\" });            // Tilde escaped at start of token\r\nvalidator.parse({ pointer: \"/field~0\" });            // Tilde escaped at end of token\r\nvalidator.parse({ pointer: \"/foo~0bar~1baz\" });      // Multiple escapes in one token\r\n\r\n// Real-world JSON structure examples\r\n// For JSON: { \"user\": { \"settings\": { \"theme\": \"dark\" } } }\r\nvalidator.parse({ pointer: \"/user\" });               // Access user object\r\nvalidator.parse({ pointer: \"/user/settings\" });      // Access nested settings\r\nvalidator.parse({ pointer: \"/user/settings/theme\" }); // Access theme value\r\n\r\n// For JSON: { \"items\": [{\"name\": \"Item1\"}, {\"name\": \"Item2\"}] }\r\nvalidator.parse({ pointer: \"/items\" });              // Access items array\r\nvalidator.parse({ pointer: \"/items/0\" });            // First item\r\nvalidator.parse({ pointer: \"/items/1\" });            // Second item\r\nvalidator.parse({ pointer: \"/items/0/name\" });       // Name of first item\r\n\r\n// For JSON with special property names\r\n// { \"\": \"empty name\", \"a/b\": \"slash in name\", \"c~d\": \"tilde in name\" }\r\nvalidator.parse({ pointer: \"/\" });                   // Empty property name\r\nvalidator.parse({ pointer: \"/a~1b\" });               // Property \"a/b\" (/ escaped as ~1)\r\nvalidator.parse({ pointer: \"/c~0d\" });               // Property \"c~d\" (~ escaped as ~0)\r\n\r\n// Edge cases\r\nvalidator.parse({ pointer: \"/0\" });                  // String \"0\" as property name\r\nvalidator.parse({ pointer: \"/-1\" });                 // String \"-1\" as property name\r\nvalidator.parse({ pointer: \"/123\" });                // Numeric string as property name\r\nvalidator.parse({ pointer: \"/true\" });               // Boolean string as property name\r\nvalidator.parse({ pointer: \"/null\" });               // Null string as property name\r\n\n// ❌ INVALID JSON Pointers\r\nvalidator.parse({ pointer: \"foo\" });                 // Missing initial slash\r\nvalidator.parse({ pointer: \"foo/bar\" });             // Missing initial slash\r\nvalidator.parse({ pointer: \"/foo/\" });               // Trailing slash (points to empty property)\r\nvalidator.parse({ pointer: \"/foo//\" });              // Double slash (empty token)\r\nvalidator.parse({ pointer: \"/~\" });                  // Incomplete escape sequence\r\nvalidator.parse({ pointer: \"/~2\" });                 // Invalid escape sequence (only ~0 and ~1 allowed)\r\nvalidator.parse({ pointer: \"/~3\" });                 // Invalid escape sequence\r\nvalidator.parse({ pointer: \"/foo~\" });               // Incomplete escape at end\r\nvalidator.parse({ pointer: \"/foo~bar\" });            // Tilde without proper escape\r\nvalidator.parse({ pointer: \"/foo~/bar\" });           // Incomplete escape in middle\r\nvalidator.parse({ pointer: \"~/foo\" });               // Escape at start without leading slash\r\nvalidator.parse({ pointer: \"/foo bar\" });            // Space in token (technically valid by RFC but often problematic)\r\nvalidator.parse({ pointer: \"/foo\\tbar\" });           // Tab character\r\nvalidator.parse({ pointer: \"/foo\\nbar\" });           // Newline character\r\nvalidator.parse({ pointer: \"/foo\\rbar\" });           // Carriage return\r\nvalidator.parse({ pointer: \"/foo\\\"bar\" });           // Double quote (valid but can be problematic)\r\nvalidator.parse({ pointer: \"/foo'bar\" });            // Single quote (valid but can be problematic)\r\nvalidator.parse({ pointer: \"/foo\\\\bar\" });           // Backslash (valid but can be confusing)\r\nvalidator.parse({ pointer: \" /foo\" });               // Leading space\r\nvalidator.parse({ pointer: \"/foo \" });               // Trailing space\r\nvalidator.parse({ pointer: \"//foo\" });               // Double slash at start"
      }
    ],
    "returns": "Validation function that checks JSON Pointer format"
  },
  {
    "functionName": "stringMax",
    "displayName": "max",
    "category": "standard",
    "description": "Validates that a string does not exceed the specified maximum length",
    "usage": ".v(\"description\", b => b.string.min(10).max(200)",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "max",
        "type": "number",
        "optional": false,
        "description": "Maximum character count"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - set maximum string length",
        "code": "// Basic usage - set maximum string length\r\nconst validator = Builder()\r\n  .use(stringMaxPlugin)\r\n  .for<UserProfile>()\r\n  .v(\"username\", (b) => b.string.max(20))\r\n  .v(\"bio\", (b) => b.string.max(500))\r\n  .build();\r\n\n// Combined with min for length range\r\nbuilder.v(\"description\", b => b.string.min(10).max(200))"
      }
    ],
    "returns": "Validation function that returns true if string length is within the maximum"
  },
  {
    "functionName": "stringMin",
    "displayName": "min",
    "category": "standard",
    "description": "Validates that a string has at least the specified minimum length",
    "usage": ".v(\"bio\", b => b.string.required().min(10)",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "min",
        "type": "number",
        "optional": false,
        "description": "Minimum character count"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - set minimum string length",
        "code": "// Basic usage - set minimum string length\r\nconst validator = Builder()\r\n  .use(stringMinPlugin)\r\n  .for<UserProfile>()\r\n  .v(\"password\", (b) => b.string.min(8))\r\n  .v(\"username\", (b) => b.string.min(3))\r\n  .build();\r\n\n// Combined with other validators\r\nbuilder.v(\"bio\", b => b.string.required().min(10).max(500))"
      }
    ],
    "returns": "Validation function that returns true if string length is at least the minimum"
  },
  {
    "functionName": "stringPattern",
    "displayName": "pattern",
    "category": "standard",
    "description": "Validates that a string matches a regular expression pattern",
    "usage": ".v(\"hexColor\", b => b.string.pattern(/^#[0-9A-Fa-f]{6}$/))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "pattern",
        "type": "RegExp",
        "optional": false,
        "description": "Regular expression to match against"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validate against regex pattern",
        "code": "// Basic usage - validate against regex pattern\r\nconst validator = Builder()\r\n  .use(stringPatternPlugin)\r\n  .for<UserData>()\r\n  .v(\"phone\", (b) => b.string.pattern(/^\\d{3}-\\d{3}-\\d{4}$/))\r\n  .v(\"zipCode\", (b) => b.string.pattern(/^\\d{5}(-\\d{4})?$/))\r\n  .build();\r\n\n// Common patterns\r\nbuilder.v(\"hexColor\", b => b.string.pattern(/^#[0-9A-Fa-f]{6}$/))\r\nbuilder.v(\"slug\", b => b.string.pattern(/^[a-z0-9-]+$/))"
      }
    ],
    "returns": "Validation function that returns true if string matches the pattern"
  },
  {
    "functionName": "stringRelativeJsonPointer",
    "displayName": "relativeJsonPointer",
    "category": "string",
    "description": "Validates Relative JSON Pointer format (draft-handrews-relative-json-pointer)",
    "usage": "builder.v(\"field\", b => b.string.relativeJsonPointer(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "stringRelativeJsonPointer Example",
        "code": "const validator = Builder()\r\n  .use(stringRelativeJsonPointerPlugin)\r\n  .for<{ pointer: string }>()\r\n  .v(\"pointer\", (b) => b.string.relativeJsonPointer())\r\n  .build();\r\n\r\n// Valid: 0 (current location)\r\n// Valid: 1/foo/bar (up 1 level, then to /foo/bar)\r\n// Valid: 2/0 (up 2 levels, then to index 0)\r\n// Valid: 0# (current location's key/index)"
      }
    ],
    "returns": "Validation function that checks Relative JSON Pointer format"
  },
  {
    "functionName": "stringStartsWith",
    "displayName": "startsWith",
    "category": "standard",
    "description": "Validates that a string begins with a specific prefix",
    "usage": ".v(\"secureUrl\", b => b.string.startsWith(\"https://\").url()",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "prefix",
        "type": "string",
        "optional": false,
        "description": "The prefix that the string must start with"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - checks if string starts with prefix",
        "code": "// Basic usage - checks if string starts with prefix\r\nconst validator = Builder()\r\n  .use(stringStartsWithPlugin)\r\n  .for<ApiData>()\r\n  .v(\"url\", (b) => b.string.startsWith(\"https://\"))\r\n  .v(\"apiKey\", (b) => b.string.required().startsWith(\"sk_\"))\r\n  .build();\r\n\n// For protocol validation\r\nbuilder.v(\"secureUrl\", b => b.string.startsWith(\"https://\").url())\r\n\n// For ID prefixes\r\nbuilder.v(\"orderId\", b => b.string.startsWith(\"ORD-\").pattern(/^ORD-\\d{8}$/))"
      }
    ],
    "returns": "Validation function that returns true if string starts with the prefix"
  },
  {
    "functionName": "stringTime",
    "displayName": "time",
    "category": "string",
    "description": "Validates time format (HH:MM:SS or HH:MM:SS.mmm)",
    "usage": "builder.v(\"field\", b => b.string.time(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string; allowMilliseconds?: boolean }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "stringTime Example",
        "code": "const validator = Builder()\r\n  .use(stringTimePlugin)\r\n  .for<{ startTime: string }>()\r\n  .v(\"startTime\", (b) => b.string.time())\r\n  .build();"
      }
    ],
    "returns": "Validation function that checks time format"
  },
  {
    "functionName": "stringUriTemplate",
    "displayName": "uriTemplate",
    "category": "string",
    "description": "Validates URI Template format (RFC 6570)",
    "usage": "builder.v(\"field\", b => b.string.uriTemplate(\"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "stringUriTemplate Example",
        "code": "const validator = Builder()\r\n  .use(stringUriTemplatePlugin)\r\n  .for<{ template: string }>()\r\n  .v(\"template\", (b) => b.string.uriTemplate())\r\n  .build();\r\n\r\n// Valid: https://api.example.com/users/{id}\r\n// Valid: /search{?q,lang}\r\n// Valid: /path{/segments*}\r\n// Valid: {+path}/here\r\n// Valid: {#section}"
      }
    ],
    "returns": "Validation function that checks URI Template format"
  },
  {
    "functionName": "stringUrl",
    "displayName": "stringUrl",
    "category": "standard",
    "description": "Validates that a string is a valid URL format",
    "usage": "builder.v(\"field\", b => b.string.stringUrl(..., \"value\", true, \"value\"))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "StringUrlOptions",
        "optional": true,
        "description": "URL validation configuration"
      },
      {
        "name": "protocols",
        "type": "string[]",
        "optional": true,
        "description": "Allowed protocols (default: all protocols allowed)"
      },
      {
        "name": "allowWithoutProtocol",
        "type": "boolean",
        "optional": true,
        "description": "Allow URLs without protocol (default: false)"
      },
      {
        "name": "messageFactory",
        "type": "(context: MessageContext) => string",
        "optional": true,
        "description": "Custom error message factory"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validates all URL formats (RFC 3986 compliant)",
        "code": "// Basic usage - validates all URL formats (RFC 3986 compliant)\r\nconst validator = Builder()\r\n  .use(stringUrlPlugin)\r\n  .for<UserProfile>()\r\n  .v(\"website\", (b) => b.string.url())\r\n  .v(\"profileUrl\", (b) => b.string.required().url())\r\n  .build();\r\n\n// Custom protocols (e.g., allow ftp://)\r\nbuilder.v(\"ftpServer\", b => b.string.url({\r\n  protocols: ['ftp:', 'ftps:']\r\n}))\r\n\n// Allow URLs without protocol (assumes https://)\r\nbuilder.v(\"domain\", b => b.string.url({\r\n  allowWithoutProtocol: true\r\n}))\r\n\n// ✅ VALID URL formats (RFC 3986)\r\nvalidator.parse({ website: \"https://example.com\" });                    // Standard HTTPS\r\nvalidator.parse({ website: \"http://www.test.co.uk/path?q=value#frag\" }); // Full URL with query and fragment\r\nvalidator.parse({ website: \"ftp://files.domain.com/file.txt\" });        // FTP protocol\r\nvalidator.parse({ website: \"ws://localhost:3000\" });                    // WebSocket protocol\r\nvalidator.parse({ website: \"https://subdomain.example.com:8080/api\" }); // With port and path\r\nvalidator.parse({ website: \"https://127.0.0.1:3000\" });                // IP address\r\nvalidator.parse({ website: \"https://[::1]:8080\" });                    // IPv6 address\r\nvalidator.parse({ website: \"mailto:user@example.com\" });                // mailto protocol\r\nvalidator.parse({ website: \"tel:+1-555-123-4567\" });                   // tel protocol\r\nvalidator.parse({ website: \"https://user:pass@example.com\" });          // With credentials\r\n\n// With allowWithoutProtocol: true\r\nconst flexValidator = builder.v(\"site\", b => b.string.url({ allowWithoutProtocol: true }));\r\nflexValidator.parse({ site: \"example.com\" });                          // Assumes https://\r\nflexValidator.parse({ site: \"www.domain.co.uk/path\" });                // Assumes https://\r\n\n// ❌ INVALID URL formats\r\nvalidator.parse({ website: \"not-a-url\" });              // Plain text\r\nvalidator.parse({ website: \"http://\" });                // Missing host\r\nvalidator.parse({ website: \"://missing-protocol\" });    // Missing protocol\r\nvalidator.parse({ website: \"https://\" });               // Missing host after protocol\r\nvalidator.parse({ website: \"http://.com\" });            // Invalid host\r\nvalidator.parse({ website: \"https://example.\" });       // Incomplete domain\r\nvalidator.parse({ website: \"just text with spaces\" });  // Contains spaces\r\nvalidator.parse({ website: \"ftp://[invalid-ipv6]\" });   // Invalid IPv6\r\nvalidator.parse({ website: \"https://exam ple.com\" });   // Space in domain\r\nvalidator.parse({ website: \"\" });                       // Empty string"
      }
    ],
    "returns": "Validation function that returns true if string is a valid URL"
  },
  {
    "functionName": "transform",
    "displayName": "transform",
    "category": "transform",
    "description": "Transforms values after successful validation (type conversion, normalization, computed values)",
    "usage": ".v(\"field\", b => b.string.transform(value => transformedValue))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [
      {
        "name": "transformFn",
        "type": "(value: T) => U",
        "optional": false,
        "description": "Transform function that takes input value and returns transformed value"
      }
    ],
    "examples": [
      {
        "title": "String transformation (lowercase)",
        "code": "// String transformation (lowercase)\r\nconst validator = Builder()\r\n  .use(transformPlugin)\r\n  .for<UserData>()\r\n  .v(\"email\", (b) =>\r\n    b.string.required().email().transform(v => v.toLowerCase())\r\n  )\r\n  .build();\r\n\n// Number to string conversion\r\nbuilder.v(\"age\", b =>\r\n  b.number.required().min(0).transform(v => String(v))\r\n)\r\n\n// Array element transformation\r\nbuilder.v(\"tags\", b =>\r\n  b.array.transform(tags => tags.map(t => t.trim().toLowerCase()))\r\n)"
      }
    ],
    "returns": "Validation function with transformation"
  },
  {
    "functionName": "tupleBuilder",
    "displayName": "tupleBuilder",
    "category": "composable-directly",
    "description": "Validates tuple types (fixed-length arrays with different types for each element)",
    "usage": "builder.v(\"field\", b => b.string.tupleBuilder(...))",
    "supportedTypes": [
      "tuple"
    ],
    "parameters": [
      {
        "name": "options",
        "type": "{ rest?: (context: FieldBuilderContext) => any }",
        "optional": true,
        "description": "Optional configuration (automatically defaults to {} when omitted)"
      }
    ],
    "examples": [
      {
        "title": "Fixed-length tuple - no options needed",
        "code": "// Fixed-length tuple - no options needed\r\ntype Coordinates = [number, number];\r\n\nconst validator = Builder()\r\n  .use(tupleBuilderPlugin)\r\n  .for<{ location: Coordinates }>()\r\n  .v(\"location\", (b) => b.tuple\r\n    .required()\r\n    .builder(\r\n      (a) => a.number.required().min(0),\r\n      (b) => b.number.required().min(0)\r\n    )\r\n  )\r\n  .build();\r\n\n// Variable-length tuple with rest elements\r\ntype UserData = [string, number, boolean, ...string[]];\r\n\nconst userValidator = Builder()\r\n  .use(tupleBuilderPlugin)\r\n  .for<{ data: UserData }>()\r\n  .v(\"data\", (b) => b.tuple\r\n    .required()\r\n    .builder(\r\n      (a) => a.string.required().min(3),     // name\r\n      (b) => b.number.required().min(0),     // age\r\n      (c) => c.boolean.required(),           // isActive\r\n      { rest: (r) => r.string.optional() }   // rest elements\r\n    )\r\n  )\r\n  .build();"
      }
    ],
    "returns": "Composable validation function"
  },
  {
    "functionName": "unionGuard",
    "displayName": "unionGuard",
    "category": "composable-conditional",
    "description": "Validates union types by applying different validation rules based on type guards",
    "usage": "builder.v(\"field\", b => b.string.unionGuard(..., ...))",
    "supportedTypes": [
      "union"
    ],
    "parameters": [
      {
        "name": "condition",
        "type": "TypeGuardCondition",
        "optional": false,
        "description": "Type guard function that returns true if value matches the type"
      },
      {
        "name": "builderFn",
        "type": "(context: FieldBuilderContext) => any",
        "optional": false,
        "description": "Builder function for the specific type"
      }
    ],
    "examples": [
      {
        "title": "Union type validation with type guards",
        "code": "// Union type validation with type guards\r\ntype StringOrNumber = string | number;\r\n\nconst validator = Builder()\r\n  .use(unionGuardPlugin)\r\n  .for<{ value: StringOrNumber }>()\r\n  .v(\"value\", (b) => b.union\r\n    .guard(\r\n      (v): v is string => typeof v === 'string',\r\n      (b) => b.string.min(3)\r\n    )\r\n    .guard(\r\n      (v): v is number => typeof v === 'number',\r\n      (b) => b.number.min(0).max(100)\r\n    )\r\n  )\r\n  .build();"
      }
    ],
    "returns": "Composable validation function that can chain multiple guards"
  },
  {
    "functionName": "uuid",
    "displayName": "uuid",
    "category": "standard",
    "description": "Validates that a string is a valid UUID (Universally Unique Identifier)",
    "usage": ".v(\"userId\", b => b.string.uuid(4))",
    "supportedTypes": [
      "string"
    ],
    "parameters": [
      {
        "name": "version",
        "type": "1 | 3 | 4 | 5 | 6 | 7 | 8",
        "optional": true,
        "description": "Specific UUID version to validate (optional)"
      },
      {
        "name": "options",
        "type": "{ messageFactory?: (context: MessageContext) => string }",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Basic usage - validate any UUID version (RFC 4122 compliant)",
        "code": "// Basic usage - validate any UUID version (RFC 4122 compliant)\r\nconst validator = Builder()\r\n  .use(uuidPlugin)\r\n  .for<Entity>()\r\n  .v(\"id\", (b) => b.string.uuid())\r\n  .v(\"correlationId\", (b) => b.string.required().uuid())\r\n  .build();\r\n\n// Validate specific UUID version\r\nbuilder.v(\"userId\", b => b.string.uuid(4))  // UUID v4 only\r\nbuilder.v(\"namespaceId\", b => b.string.uuid(5))  // UUID v5 only\r\nbuilder.v(\"timestamp\", b => b.string.uuid(7))  // UUID v7 only (time-based)\r\n\n// ✅ VALID UUID formats (RFC 4122)\r\n// UUID v1 (MAC address + timestamp based)\r\nvalidator.parse({ id: \"12345678-1234-1234-8123-123456789abc\" });\r\nvalidator.parse({ id: \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" });\r\n\r\n// UUID v3 (MD5 hash based)\r\nvalidator.parse({ id: \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\" });\r\nvalidator.parse({ id: \"12345678-1234-3234-8123-123456789abc\" });\r\n\r\n// UUID v4 (random)\r\nvalidator.parse({ id: \"550e8400-e29b-41d4-a716-446655440000\" });\r\nvalidator.parse({ id: \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" });\r\nvalidator.parse({ id: \"12345678-1234-4234-9123-123456789abc\" });\r\n\r\n// UUID v5 (SHA-1 hash based)\r\nvalidator.parse({ id: \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\" });\r\nvalidator.parse({ id: \"12345678-1234-5234-8123-123456789abc\" });\r\n\r\n// UUID v6 (reordered timestamp)\r\nvalidator.parse({ id: \"1EC9414C-232A-6B00-B3C8-9E6BDECED846\" });\r\nvalidator.parse({ id: \"12345678-1234-6234-9123-123456789abc\" });\r\n\r\n// UUID v7 (Unix timestamp based)\r\nvalidator.parse({ id: \"017F22E2-79B0-7CC3-98C4-DC0C0C07398F\" });\r\nvalidator.parse({ id: \"12345678-1234-7234-8123-123456789abc\" });\r\n\r\n// UUID v8 (custom/application-specific)\r\nvalidator.parse({ id: \"12345678-1234-8234-9123-123456789abc\" });\r\n\r\n// Case insensitive\r\nvalidator.parse({ id: \"F47AC10B-58CC-4372-A567-0E02B2C3D479\" });\r\nvalidator.parse({ id: \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" });\r\n\n// ❌ INVALID UUID formats\r\nvalidator.parse({ id: \"not-a-uuid\" });                      // Plain text\r\nvalidator.parse({ id: \"12345678-1234-1234-1234-123456789\" }); // Too short\r\nvalidator.parse({ id: \"12345678-1234-1234-1234-123456789abcd\" }); // Too long\r\nvalidator.parse({ id: \"12345678-1234-0234-8123-123456789abc\" }); // Invalid version (0)\r\nvalidator.parse({ id: \"12345678-1234-9234-8123-123456789abc\" }); // Invalid version (9)\r\nvalidator.parse({ id: \"12345678-1234-4234-0123-123456789abc\" }); // Invalid variant (0)\r\nvalidator.parse({ id: \"12345678-1234-4234-c123-123456789abc\" }); // Invalid variant (c)\r\nvalidator.parse({ id: \"12345678-1234-4234-g123-123456789abc\" }); // Invalid hex char (g)\r\nvalidator.parse({ id: \"12345678123412348123123456789abc\" });     // Missing hyphens\r\nvalidator.parse({ id: \"12345678-1234-4234-8123-123456789ab\" });  // Missing last char\r\nvalidator.parse({ id: \"12345678-1234-4234-8123-123456789abcX\" }); // Extra char\r\nvalidator.parse({ id: \"\" });                                    // Empty string\r\nvalidator.parse({ id: \"12345678-1234-4234-8123-123456789ab \" }); // Trailing space\r\nvalidator.parse({ id: \" 12345678-1234-4234-8123-123456789abc\" }); // Leading space"
      }
    ],
    "returns": "Validation function that returns true if string is a valid UUID"
  },
  {
    "functionName": "validateIf",
    "displayName": "validateIf",
    "category": "conditional",
    "description": "Conditionally applies all validation rules to a field based on a dynamic condition, with support for array context validation",
    "usage": ".v(\"field\", b => b.string.validateIf(condition))",
    "supportedTypes": [
      "string",
      "number",
      "boolean",
      "array",
      "object",
      "date",
      "union"
    ],
    "parameters": [
      {
        "name": "condition",
        "type": "(allValues: TObject, arrayContext?: ArrayContext) => boolean",
        "optional": false,
        "description": "Function that returns true if validation should run, with access to array context"
      },
      {
        "name": "options",
        "type": "ValidationOptions",
        "optional": true,
        "description": "Optional configuration"
      }
    ],
    "examples": [
      {
        "title": "Validate URL only when custom endpoint is enabled",
        "code": "// Validate URL only when custom endpoint is enabled\r\nconst validator = Builder()\r\n  .use(validateIfPlugin)\r\n  .for<ConfigData>()\r\n  .v(\"customEndpoint\", b =>\r\n    b.string\r\n      .validateIf(values => values.useCustomEndpoint)\r\n      .url()\r\n      .min(10)\r\n  )\r\n  .build();\r\n\n// Skip validation in local environment\r\nbuilder.v(\"apiKey\", b =>\r\n  b.string\r\n    .validateIf(values => values.environment !== 'local')\r\n    .required()\r\n    .min(32)\r\n)\r\n\n// Conditional sections in forms\r\nbuilder.v(\"businessDetails.taxId\", b =>\r\n  b.string\r\n    .validateIf(values => values.accountType === 'business')\r\n    .required()\r\n    .pattern(/^\\d{9}$/)\r\n)"
      }
    ],
    "returns": "Validation function that skips all validations when condition is false"
  }
];

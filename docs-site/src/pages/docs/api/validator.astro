---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import Header from '../../../components/Header.astro';
import Footer from '../../../components/Footer.astro';
import DocsSidebar from '../../../components/DocsSidebar.astro';
import CodeBlock from '../../../components/CodeBlock.astro';
import OnThisPage from '../../../components/OnThisPage.astro';

// Table of contents
const tableOfContents = [
  { id: 'overview', title: 'Overview', level: 2 },
  { id: 'creating-validator', title: 'Creating a Validator', level: 2 },
  { id: 'validation-methods', title: 'Validation Methods', level: 2 },
  { id: 'validate-method', title: 'validate() Method', level: 3 },
  { id: 'parse-method', title: 'parse() Method', level: 3 },
  { id: 'pick-method', title: 'pick() Method', level: 3 },
  { id: 'result-object', title: 'Result Object', level: 2 },
  { id: 'result-methods', title: 'Result Methods', level: 3 },
  { id: 'error-handling', title: 'Error Handling', level: 3 },
  { id: 'functional-methods', title: 'Functional Methods', level: 3 },
  { id: 'validation-options', title: 'Validation Options', level: 2 },
  { id: 'complete-examples', title: 'Complete Examples', level: 2 },
];

// Code examples
const creatingValidatorExample = `import { Builder } from '@maroonedog/luq/core';
import { 
  requiredPlugin, 
  stringMinPlugin,
  numberMinPlugin,
  transformPlugin 
} from '@maroonedog/luq/plugin';

// Define your type
type UserData = {
  name: string;
  age: number;
  email: string;
};

// Create validator using Builder
const validator = Builder()
  .use(requiredPlugin)
  .use(stringMinPlugin)
  .use(numberMinPlugin)
  .for<UserData>()
  .v('name', b => b.string.required().min(2))
  .v('age', b => b.number.required().min(18))
  .v('email', b => b.string.required())
  .build(); // Returns a Validator instance`;

const validateMethodExample = `// validate() returns original values (no transformations applied)
const result = validator.validate({
  name: 'John Doe',
  age: 25,
  email: 'john@example.com'
});

// Check if validation passed
if (result.isValid()) {
  const data = result.unwrap();
  console.log('Valid data:', data);
  // data type is UserData with original values
} else {
  console.log('Validation errors:', result.errors);
}

// Using the 'valid' property (backward compatibility)
if (result.valid) {
  console.log('Valid!');
}`;

const parseMethodExample = `// Define a validator with transformations
const transformValidator = Builder()
  .use(requiredPlugin)
  .use(transformPlugin)
  .for<{ email: string; age: string }>()
  .v('email', b => b.string.required()
    .transform(email => email.toLowerCase().trim()))
  .v('age', b => b.string.required()
    .transform(age => parseInt(age, 10)))
  .build();

// parse() applies transformations and returns transformed values
const result = transformValidator.parse({
  email: '  JOHN@EXAMPLE.COM  ',
  age: '25'
});

if (result.isValid()) {
  const data = result.unwrap();
  // data.email is 'john@example.com' (lowercased and trimmed)
  // data.age is 25 (number, not string)
}`;

const resultMethodsExample = `const result = validator.validate(inputData);

// Check validity
if (result.isValid()) {
  // Successfully validated
}

if (result.isError()) {
  // Validation failed
}

// Get data with different strategies
const data1 = result.unwrap();           // Throws if invalid
const data2 = result.unwrapOr(defaultData); // Returns default if invalid
const data3 = result.unwrapOrElse(
  errors => computeDefault(errors)       // Lazy default computation
);

// Direct access (use with caution)
const maybeData = result.data();         // T | undefined
const errors = result.errors;            // ValidationError[]`;

const errorHandlingExample = `// ValidationError structure
interface ValidationError {
  path: string;    // Field path like 'user.email'
  message: string; // Human-readable error message
  code: string;    // Error code like 'required' or 'min_length'
}

// Handling validation errors
const result = validator.validate(invalidData);

if (!result.isValid()) {
  // Access all errors
  result.errors.forEach(error => {
    console.log(\`\${error.path}: \${error.message} (\${error.code})\`);
  });
  
  // Use tapError for side effects
  result.tapError(errors => {
    logValidationErrors(errors);
  });
  
  // Or throw exception
  try {
    result.unwrap(); // Throws LuqValidationException
  } catch (e) {
    if (e.name === 'LuqValidationException') {
      console.log('Validation failed:', e.message);
      console.log('Errors:', e.errors);
    }
  }
}`;

const functionalMethodsExample = `// Transform valid data
const transformed = result
  .map(data => ({
    ...data,
    timestamp: Date.now()
  }))
  .map(data => normalizeData(data));

// Chain validations
const finalResult = validator1.validate(data)
  .flatMap(validData => validator2.validate(validData))
  .flatMap(validData => validator3.validate(validData));

// Side effects without changing the result
const result = validator.validate(data)
  .tap(validData => {
    console.log('Valid:', validData);
    saveToDatabase(validData);
  })
  .tapError(errors => {
    console.error('Invalid:', errors);
    logErrors(errors);
  });

// Convert to plain object (for JSON serialization)
const plain = result.toPlainObject();
// { valid: boolean, data?: T, errors: ValidationError[] }`;

const pickMethodExample = `// Extract single field validator from a built validator
const userValidator = Builder()
  .use(requiredPlugin)
  .use(stringEmailPlugin)
  .use(stringMinPlugin)
  .use(numberMinPlugin)
  .for<UserProfile>()
  .v('email', b => b.string.required().email())
  .v('username', b => b.string.required().min(3))
  .v('age', b => b.number.required().min(18))
  .v('profile.bio', b => b.string.optional().max(500))
  .build();

// Use pick() to extract a single field validator
const emailValidator = userValidator.pick('email');
const ageValidator = userValidator.pick('age');
const bioValidator = userValidator.pick('profile.bio'); // Nested fields supported

// Validate individual fields
const emailResult = emailValidator.validate('test@example.com');
if (emailResult.valid) {
  console.log('Valid email:', emailResult.value);
}

const ageResult = ageValidator.validate(25);
if (ageResult.valid) {
  console.log('Valid age:', ageResult.value);
}

// Picked validators are type-safe
// emailValidator is FieldValidator<UserProfile, string>
// ageValidator is FieldValidator<UserProfile, number>
// bioValidator is FieldValidator<UserProfile, string | undefined>

// Can provide context (other field values) for field dependencies
const bioResult = bioValidator.validate('My bio text', {
  username: 'john_doe',
  age: 25
});`;

const validationOptionsExample = `// ValidationOptions interface
interface ValidationOptions {
  abortEarly?: boolean;  // Stop at first error (default: false)
  context?: any;         // Additional context for validation
}

// Using validation options
const result = validator.validate(data, {
  abortEarly: true,  // Stop at first error
  context: {
    user: currentUser,
    timestamp: Date.now()
  }
});

// Options are passed to all field validators
// Useful for conditional validation based on context`;

const completeExample1 = `// Form validation example
import { Builder } from '@maroonedog/luq/core';
import { 
  requiredPlugin,
  stringMinPlugin,
  stringEmailPlugin,
  transformPlugin,
  compareFieldPlugin
} from '@maroonedog/luq/plugin';

type RegistrationForm = {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  age: string; // From form input
};

const registrationValidator = Builder()
  .use(requiredPlugin)
  .use(stringMinPlugin)
  .use(stringEmailPlugin)
  .use(transformPlugin)
  .use(compareFieldPlugin)
  .for<RegistrationForm>()
  .v('username', b => b.string.required().min(3))
  .v('email', b => b.string.required().email())
  .v('password', b => b.string.required().min(8))
  .v('confirmPassword', b => b.string.required().compareField('password'))
  .v('age', b => b.string.required().transform(v => parseInt(v, 10)))
  .build();

// Handle form submission
function handleSubmit(formData: RegistrationForm) {
  const result = registrationValidator.parse(formData);
  
  return result
    .map(data => {
      // age is now a number
      return createUser(data);
    })
    .tap(user => {
      console.log('User created:', user.id);
    })
    .tapError(errors => {
      displayFormErrors(errors);
    });
}`;

const completeExample2 = `// API validation with error response
import { Result } from '@maroonedog/luq';

async function updateUserEndpoint(req: Request): Promise<Response> {
  const body = await req.json();
  
  const result = userUpdateValidator.validate(body);
  
  // Early return for validation errors
  if (!result.isValid()) {
    return new Response(JSON.stringify({
      success: false,
      errors: result.errors.map(e => ({
        field: e.path,
        message: e.message,
        code: e.code
      }))
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  // Process valid data
  const userData = result.unwrap();
  const updated = await updateUser(userData);
  
  return new Response(JSON.stringify({
    success: true,
    data: updated
  }), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}`;

const completeExample3 = `// Composing multiple validators
const addressValidator = Builder()
  .use(requiredPlugin)
  .for<Address>()
  .v('street', b => b.string.required())
  .v('city', b => b.string.required())
  .v('zipCode', b => b.string.required())
  .build();

const userValidator = Builder()
  .use(requiredPlugin)
  .for<User>()
  .v('name', b => b.string.required())
  .v('email', b => b.string.required())
  .build();

// Compose validators
function validateComplete(data: any): Result<CompleteData> {
  const userResult = userValidator.validate(data.user);
  const addressResult = addressValidator.validate(data.address);
  
  if (!userResult.isValid()) return userResult;
  if (!addressResult.isValid()) return addressResult;
  
  return Result.ok({
    user: userResult.unwrap(),
    address: addressResult.unwrap()
  });
}`;
---

<BaseLayout title="Validator API - Luq Documentation">
  <Header />
  
  <div class="flex min-h-screen">
    <DocsSidebar currentPath="/docs/api/validator" />
    
    <main class="flex-1 px-4 sm:px-6 lg:px-8 py-8 pt-20 lg:pt-8">
      <article class="max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold mb-8">Validator API</h1>
        
        <div class="prose prose-lg dark:prose-invert max-w-none">
          <p class="lead">
            The Validator is the runtime validation engine created by the Builder. It provides methods to validate data and handle results using a functional Result pattern.
          </p>
          
          <h2 id="overview">Overview</h2>
          
          <p>
            A Validator instance is created by calling <code>.build()</code> on a configured Builder. The validator provides two main methods:
          </p>
          
          <ul>
            <li><strong>validate()</strong> - Validates data and returns original values</li>
            <li><strong>parse()</strong> - Validates data and returns transformed values</li>
          </ul>
          
          <p>
            Both methods return a <code>Result&lt;T&gt;</code> object that provides safe, functional error handling.
          </p>
          
          <h2 id="creating-validator">Creating a Validator</h2>
          
          <CodeBlock code={creatingValidatorExample} language="typescript" showCopy={true} />
          
          <h2 id="validation-methods">Validation Methods</h2>
          
          <h3 id="validate-method">validate() Method</h3>
          
          <p>
            The <code>validate()</code> method checks if data conforms to the schema and returns the original values without applying any transformations:
          </p>
          
          <CodeBlock code={validateMethodExample} language="typescript" showCopy={true} />
          
          <div class="not-prose bg-luq-blue-50 dark:bg-luq-blue-900/20 rounded-lg p-6 my-6">
            <h4 class="font-semibold mb-3">💡 When to use validate()</h4>
            <ul class="space-y-2 text-sm">
              <li>• When you only need to check if data is valid</li>
              <li>• When you want to preserve original values</li>
              <li>• When transformations are not needed</li>
              <li>• For validation-only scenarios</li>
            </ul>
          </div>
          
          <h3 id="parse-method">parse() Method</h3>
          
          <p>
            The <code>parse()</code> method validates data AND applies all transformations, returning the transformed values:
          </p>
          
          <CodeBlock code={parseMethodExample} language="typescript" showCopy={true} />
          
          <div class="not-prose bg-luq-purple-50 dark:bg-luq-purple-900/20 rounded-lg p-6 my-6">
            <h4 class="font-semibold mb-3">📝 When to use parse()</h4>
            <ul class="space-y-2 text-sm">
              <li>• When you have transform plugins in your validator</li>
              <li>• When you need normalized/sanitized data</li>
              <li>• When converting types (e.g., string to number)</li>
              <li>• For data processing pipelines</li>
            </ul>
          </div>
          
          <h3 id="pick-method">pick() Method</h3>
          
          <p>
            The <code>pick()</code> method extracts a single field validator from a built validator, enabling individual field validation:
          </p>
          
          <CodeBlock code={pickMethodExample} language="typescript" showCopy={true} />
          
          <div class="not-prose bg-green-50 dark:bg-green-900/20 rounded-lg p-6 my-6">
            <h4 class="font-semibold mb-3">🎯 When to use pick()</h4>
            <ul class="space-y-2 text-sm">
              <li>• When you need to validate individual fields in isolation</li>
              <li>• For real-time field validation in forms</li>
              <li>• When testing specific field validation logic</li>
              <li>• As an alternative to Plugin Registry for single field validation</li>
            </ul>
            
            <div class="bg-green-100 dark:bg-green-800/30 rounded p-3 mt-4">
              <p class="text-xs font-semibold">💡 Tip: If you already have a validator, use <code>pick()</code> instead of creating a separate Plugin Registry for single field validation.</p>
            </div>
          </div>
          
          <h2 id="result-object">Result Object</h2>
          
          <p>
            Both validation methods return a <code>Result&lt;T&gt;</code> object that encapsulates the validation outcome. This provides a type-safe, functional approach to error handling.
          </p>
          
          <h3 id="result-methods">Result Methods</h3>
          
          <CodeBlock code={resultMethodsExample} language="typescript" showCopy={true} />
          
          <h3 id="error-handling">Error Handling</h3>
          
          <p>
            When validation fails, the Result object provides access to detailed error information:
          </p>
          
          <CodeBlock code={errorHandlingExample} language="typescript" showCopy={true} />
          
          <h3 id="functional-methods">Functional Methods</h3>
          
          <p>
            The Result object supports functional programming patterns for composing and transforming results:
          </p>
          
          <CodeBlock code={functionalMethodsExample} language="typescript" showCopy={true} />
          
          <h2 id="validation-options">Validation Options</h2>
          
          <p>
            Both <code>validate()</code> and <code>parse()</code> accept an optional second parameter for configuration:
          </p>
          
          <CodeBlock code={validationOptionsExample} language="typescript" showCopy={true} />
          
          <h2 id="complete-examples">Complete Examples</h2>
          
          <h3>Form Validation with Transformations</h3>
          
          <CodeBlock code={completeExample1} language="typescript" showCopy={true} />
          
          <h3>API Endpoint Validation</h3>
          
          <CodeBlock code={completeExample2} language="typescript" showCopy={true} />
          
          <h3>Composing Multiple Validators</h3>
          
          <CodeBlock code={completeExample3} language="typescript" showCopy={true} />
          
          <div class="not-prose mt-12">
            <h3 class="text-2xl font-bold mb-6">API Reference</h3>
            <div class="bg-luq-neutral-50 dark:bg-luq-neutral-800 rounded-lg p-6">
              <h4 class="font-semibold mb-4">Validator Methods</h4>
              <table class="w-full mb-8">
                <thead>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <th class="text-left py-2">Method</th>
                    <th class="text-left py-2">Returns</th>
                    <th class="text-left py-2">Description</th>
                  </tr>
                </thead>
                <tbody class="text-sm">
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>validate(value, options?)</code></td>
                    <td class="py-2">Result&lt;T&gt;</td>
                    <td class="py-2">Validates and returns original values</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>parse(value, options?)</code></td>
                    <td class="py-2">Result&lt;T&gt;</td>
                    <td class="py-2">Validates and returns transformed values</td>
                  </tr>
                  <tr>
                    <td class="py-2"><code>pick(fieldName)</code></td>
                    <td class="py-2">FieldValidator&lt;T, F&gt;</td>
                    <td class="py-2">Extracts single field validator</td>
                  </tr>
                </tbody>
              </table>
              
              <h4 class="font-semibold mb-4">Result Methods</h4>
              <table class="w-full">
                <thead>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <th class="text-left py-2">Method</th>
                    <th class="text-left py-2">Returns</th>
                    <th class="text-left py-2">Description</th>
                  </tr>
                </thead>
                <tbody class="text-sm">
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>isValid()</code></td>
                    <td class="py-2">boolean</td>
                    <td class="py-2">Check if validation passed</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>isError()</code></td>
                    <td class="py-2">boolean</td>
                    <td class="py-2">Check if validation failed</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>unwrap()</code></td>
                    <td class="py-2">T</td>
                    <td class="py-2">Get data or throw exception</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>unwrapOr(default)</code></td>
                    <td class="py-2">T</td>
                    <td class="py-2">Get data or return default</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>unwrapOrElse(fn)</code></td>
                    <td class="py-2">T</td>
                    <td class="py-2">Get data or compute default</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>map(fn)</code></td>
                    <td class="py-2">Result&lt;U&gt;</td>
                    <td class="py-2">Transform valid data</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>flatMap(fn)</code></td>
                    <td class="py-2">Result&lt;U&gt;</td>
                    <td class="py-2">Chain result-returning functions</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>tap(fn)</code></td>
                    <td class="py-2">Result&lt;T&gt;</td>
                    <td class="py-2">Side effect for valid data</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>tapError(fn)</code></td>
                    <td class="py-2">Result&lt;T&gt;</td>
                    <td class="py-2">Side effect for errors</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>data()</code></td>
                    <td class="py-2">T | undefined</td>
                    <td class="py-2">Get data or undefined</td>
                  </tr>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>errors</code></td>
                    <td class="py-2">ValidationError[]</td>
                    <td class="py-2">Get validation errors</td>
                  </tr>
                  <tr>
                    <td class="py-2"><code>toPlainObject()</code></td>
                    <td class="py-2">object</td>
                    <td class="py-2">Convert to plain object</td>
                  </tr>
                </tbody>
              </table>
              
              <h4 class="font-semibold mb-4 mt-8">FieldValidator Methods (from pick())</h4>
              <table class="w-full">
                <thead>
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <th class="text-left py-2">Method</th>
                    <th class="text-left py-2">Returns</th>
                    <th class="text-left py-2">Description</th>
                  </tr>
                </thead>
                <tbody class="text-sm">
                  <tr class="border-b border-luq-neutral-200 dark:border-luq-neutral-700">
                    <td class="py-2"><code>validate(value, allValues?, options?)</code></td>
                    <td class="py-2">ValidationResult</td>
                    <td class="py-2">Validates single field value</td>
                  </tr>
                  <tr>
                    <td class="py-2">• <code>value</code></td>
                    <td class="py-2">Field type</td>
                    <td class="py-2">The field value to validate</td>
                  </tr>
                  <tr>
                    <td class="py-2">• <code>allValues</code></td>
                    <td class="py-2">Partial&lt;T&gt;</td>
                    <td class="py-2">Context with other field values</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          
          <div class="not-prose mt-12">
            <h3 class="text-2xl font-bold mb-6">Next Steps</h3>
            <div class="grid md:grid-cols-2 gap-6">
              <a href="/docs/api/plugin-registry" class="luq-card p-6 hover:shadow-lg transition-shadow">
                <h4 class="text-lg font-semibold mb-2">Plugin Registry API</h4>
                <p class="text-sm text-luq-neutral-600 dark:text-luq-neutral-400">
                  Learn about the plugin registry system
                </p>
              </a>
              
              <a href="/docs/core-concepts" class="luq-card p-6 hover:shadow-lg transition-shadow">
                <h4 class="text-lg font-semibold mb-2">Core Concepts</h4>
                <p class="text-sm text-luq-neutral-600 dark:text-luq-neutral-400">
                  Understand Luq's validation architecture
                </p>
              </a>
            </div>
          </div>
        </div>
      </article>
    </main>
    
    <OnThisPage tableOfContents={tableOfContents} />
  </div>
  
  <Footer />
</BaseLayout>

<style>
  .prose h2 {
    @apply mt-12 mb-6;
  }
  
  .prose h3 {
    @apply mt-8 mb-4;
  }
  
  table {
    @apply text-luq-neutral-700 dark:text-luq-neutral-300;
  }
  
  td code, th {
    @apply font-mono text-xs;
  }
</style>